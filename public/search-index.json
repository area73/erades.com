[
  {
    "title": "particle system",
    "description": "Exploring particle system animation techniques using Canvas and JavaScript for creating dynamic visual effects",
    "tags": [
      "particle system"
    ],
    "categories": [
      "experiment"
    ],
    "content": "<script type=\"module\" src=\"/js/experiments/system01.js\"></script> <canvas></canvas>",
    "path": "/blog/experiments/particle-system-01"
  },
  {
    "title": "Hindley-Milner notation",
    "description": "Understanding Hindley-Milner type notation in functional programming for expressing function signatures and type relationships",
    "tags": [
      "declarative",
      "Pure functions",
      "Inmutable",
      "currying",
      "Hindley-Milner"
    ],
    "categories": [
      "functional"
    ],
    "content": "A way to create a notation to express what types of parameter a function takes, and what it returns. ## The basic A function that takes a primary value (\"old type\" like string, number, boolean, array, function...) and returns another primary value: `instruction :: String -> String` ```javascript const instruction = function (verb) { return verb + \" me\"; }; ``` the function instruction takes a string and return a string You could also do something like: `length :: String → Number` ```javascript const length = function (s) { return s.length; }; ``` In the case of an array of numbers: `length :: [Number] → Number` ```javascript const length = function(arr){ retrun arr.length } ``` ## Working with functions In the case of a function, we wrap our function in parenthesis and inside the parenthesis we have our input type and our output type: `addOneToAll :: ((Number → Number),[Number]) → [Number]` ```javascript const addOne = function (x) { return x + 1; }; const addOneToAll = (addOne, arr) => arr.map(addOne); ``` In this case we have a function call addOneToAll that expects as first parameter a function (in our case addOne) and this function will accept a number and returns a nunmber. And as a second parameter an array of numers and will return another array of numbers. ### Currying functions Now what about a function that returns a function that returns another function .... Following above we will have something like this: `replace :: String -> (String -> (String -> String))` ```javascript var replace = curry(function (find, replacement, str) { var regex = new RegExp(find, \"g\"); return str.replace(regex, replacement); }); ``` In this case we also curryfy the function in order to take parameters one by one And in functional programming we can assuming that everything is curried, so we tend to drop the brackets and something like this: ` replace :: String -> String -> String -> String` ## Working with functions that takes multiple parameters as input (Hindley-Milner's Arbitrary Variables) We show the example with the length function were we could have: `length :: [Number] → Number` or `length :: string → Number` In this case we could write both with an arbitrary variable like: `length :: [a] → Number` Another common example is the identity: `identity :: a -> a` And a more complex example: `map :: (a -> b) -> [a] -> [b]` ```javascript const map = curry(function (callback, array) { return array.map(callback); }); ``` The map function takes a function that takes a variable of type `a` and returns a variable of type `b`. Then takes an **array of values**, all type `a`, and returns an **array of values**, all type `b`. --- ## Working with Ramda ## Parametrized Types We can easily imagine a type representing a collection of similar items, let's call it a Box. But no instance is an arbitrary Box; each one can only hold one sort of item. `makeBox :: Number -> Number -> Number -> [a] -> Box a` ```javascript const makeBox = curry((height, width, depth, items) => /* ... */); ``` ## Type Aliases If we had a parameterized type User String, where the String was meant to represent a name, and we wanted to be more specific about the type of String that is represented when generating a URL, we could create a type alias like this: `toUrl :: User Name u => Url -> u -> Url` `Name = String` ` Url = String` ```javascript const toUrl = curry( (base, user) => base + user.name.toLowerCase().replace(/\\W/g, \"-\") ); toUrl(\"http://example.com/users/\", { name: \"Fred Flintstone\", age: 24 }); //=> 'http://example.com/users/fred-flintstone' ``` ## Type constrains [Ord] Sometimes we want to restrict the generic types we can use in a signature in some way or another We might want a maximum function that can operate on Numbers, on Strings, on Dates, but not on arbitrary Objects. We want to describe ordered types, ones for which **a < b will always return a meaningful result** `maximum :: Ord a => [a] -> a` ```javascript const maximum = (vals) => reduce((curr, next) => (next > curr ? next : curr), head(vals), tail(vals)); maximum([3, 1, 4, 1]); //=> 4 maximum([\"foo\", \"bar\", \"baz\", \"qux\", \"quux\"]); //=> 'qux' maximum([ new Date(\"1867-07-01\"), new Date(\"1810-09-16\"), new Date(\"1776-07-04\"), ]); //=> new Date(\"1867-07-01\") ``` `Ord a ⇒ [a] → a` says that maximum takes a collection of elements of some type, but that type must adhere to Ord. In JS, there's no way to guarantee that the user will not pass us [1, 2, 'a', false, undefined, null]. So our entire type annotation is **descriptive and aspirational** rather than compiler-enforced, as it would be in, say, Haskell. ## Multiple Signatures Sometimes rather than trying to find the most generic version of a signature, it's more straightforward to list several related signatures separately. We could do that like bellow: `getIndex :: a -> [a] -> Number` ` :: String -> String -> Number` ```javascript const getIndex = curry((needle, haystack) => haystack.indexOf(needle)); getIndex(\"ba\", \"foobar\"); //=> 3 getIndex(42, [7, 14, 21, 28, 35, 42, 49]); //=> 5 ``` ## Variadic Functions (specific to Ramda) In Haskell, all functions have a fixed arity. But Javsacript has to deal with variadic functions. `flip :: (a -> b -> ... -> z) -> (b -> a -> ... -> z)` ```javascript const flip = (fn) => function (b, a) { return fn.apply(this, [a, b].concat([].slice.call(arguments, 2))); }; flip((x, y, z) => x + y + z)(\"a\", \"b\", \"c\"); //=> 'bac' ``` ## Simple Objects When an object is used as a dictionary of like-typed values (as opposed to its other role as a Record), then the types of the keys and the values can become relevant. So we could represent them like this: `keys :: {k: v} -> [k]` `values :: {k: v} -> [v]` ```javascript keys({ a: 86, b: 75, c: 309 }); //=> ['a', 'b', 'c'] values({ a: 86, b: 75, c: 309 }); //=> [86, 75, 309] ``` ## Complex example `Lens s a -> (a -> a) -> s -> s` `Lens s a = Functor f => (a -> f a) -> s -> f s` We start with the type alias, Lens s a = Functor f ⇒ (a → f a) → s → f s. This tells us that the type Lens **is parameterized by two generic variables, s, and a**. We know that there is a constraint on the type of the f variable used in a Lens: **it must be a Functor**. With that in mind, we see that a Lens is a curried function of two parameters, the first being a function from a value of the generic type a to one of the parameterized type f a, and the second being a value of generic type s. **The result** is a value of the parameterized type `f・s` <div class=\"bibliography\"> Bibliogrphy:<br><br> - [gentle introduction to functional javascript style](https://jrsinclair.com/articles/2016/gentle-introduction-to-functional-javascript-style#hindley-milnertypesignatures) - [function type signatures in Javascript](https://hackernoon.com/function-type-signatures-in-javascript-5c698c1e9801) - [Type signatures in Ramda](https://github.com/ramda/ramda/wiki/Type-Signatures) </div>",
    "path": "/blog/functional/Hindley-Milner-notation"
  },
  {
    "title": "combinators",
    "description": "Understanding combinators in functional programming as higher-order pure functions for composing and controlling program flow",
    "tags": [
      "declarative",
      "Pure functions",
      "Inmutable",
      "currying",
      "combinator"
    ],
    "categories": [
      "functional"
    ],
    "content": "A combinator are higher-order , **pure functions** that doesn't have any **free variable** and can combine primitive artifacts like other functions (or other combinators) and behave as control logic. **Free variables** are just simple variables in the context of a function that aren't explicit pass in as argument. Our commitment is that all dependencies are pass by parameter. Combinators unlock freedom and facilitate point-free programming. Because combinators are pure, they can be composed into other combinators, providing an infinite number of alternatives to express and reduce the complexity of writing any type of application. For example a composer function will be a combinator: ```javascript const compose = (f, g) => (x) => f(g(x)); const addTwo = (x) => x + 2; const multByTree = (x) => x * 3; const operator = compose(addTwo, multByTree); console.log(operator(7)); // 23 // NOTE: remember that compose will execute from right to left ``` In Ramda there are many combinators that we can use: - compose - pipe - identity - tap - alternation - sequence - fork (join) ## identity The identity combinator is a function that returns the same value it was provided as an argument: `identity :: (a) -> a` It's used extensively when examining the mathematical properties of functions, but it has other practical applications as well: - Supplying data to higher-order functions that expect it when evaluating a function argument. - Unit testing the flow of function combinators where you need a simple function result on which to make assertions. - Extracting data functionally from encapsulated types. ## Tap tap is extremely useful to bridge void functions (such as logging or writing a file or an HTML page) into your composition without having to any create additional code. It does this by passing itself into a function and returning itself. Here's the function signature: `tap :: (a -> *) -> a -> a` ## Alternation [OR - combinator] The alt combinator allows you to perform **simple conditional logic** when providing default behavior in response to a function call. This combinator takes two functions and returns the result of the first one if the value is defined (not false, null, or undefined); otherwise, it returns the result of the second function. ## Sequence (S-combinator) The seq combinator is used to loop over a sequence of functions. It takes two or more functions as parameters and returns a new function, which runs all of them in sequence against the same value. The seq combinator doesn't return a value; it just performs a set of actions one after the other. ## Fork (join) combinator The fork combinator is useful in cases where you need to process a single resource in two different ways and then combine the results. <br><br> <div class=\"bibliography\"> Bibliography:<br> - Functional Programming in JavaScript . Ed: MANNING SHELTER ISLAND. Author: Luis Atencio.<br> - [Mostly Adequate Guide to functional programming](https://drboolean.gitbooks.io/mostly-adequate-guide-old/content/). Professor Frisby's<br> - [Building a declarative app using Functional javaScript](https://www.packtpub.com/web-development/building-declarative-apps-using-functional-javascript-video). Michael Rosata </div>",
    "path": "/blog/functional/combinators"
  },
  {
    "title": "functional programming",
    "description": "An introduction to functional programming concepts including declarative programming, pure functions, immutability, and currying",
    "tags": [
      "declarative",
      "Pure functions",
      "Inmutable",
      "currying"
    ],
    "categories": [
      "functional"
    ],
    "content": "In computer science, functional programming is a programming paradigm — a style of building the structure and elements of computer programs— that treats computation as the **evaluation of mathematical functions and avoids changing-state and mutable data**. It is a **declarative** programming paradigm, which means programming is done with expressions or declarations instead of statements. To put it in a diferent way we can say that **declarative programming cares about what** to perform an action and imperative cares about how to perform that action ## Declarative Vs. Imperative || What Vs. How In functional code, the output value of a function depends only on the arguments that are passed to the function, so calling a function f twice with the same value for an argument x produces the same result f(x) each time; this is in contrast to procedures depending on a local or global state, which may produce different results at different times when called with the same arguments but a different program state. Eliminating side effects, i.e., changes in state that do not depend on the function inputs, can make it much easier to understand and predict the behavior of a program, which is one of the key motivations for the development of functional programming. In contrast, imperative programming changes state with commands in the source code, the simplest example being assignment. Imperative programming does have functions—not in the mathematical sense—but in the sense of subroutines. They can have side effects that may change the value of program state. Functions without return values therefore make sense. Because of this, they lack referential transparency, i.e., the same language expression can result in different values at different times depending on the state of the executing program. **IMPERATIVE** ```javascript for (var i = 0; i < users.length; i++) { users[i].lastModified = new Date(); } ``` **DECLARATIVE** ```javascript users.mnap((u) => { u.lastModified = new Date(); return u; }); ``` ## Mathematical Functions ( Pure Functions) Functions that with the same input always return the same output. They don't deppend in any other data other than what is passed to the funtion and don't alter dataother than what they returned ## Mutable data Mutable data is data that can be change. An example will be to order an array. If we have an unorder array and we create a function that shorts that array if the function return a new array with the shorting this will be unmutable data because we did not change the original array, but if the function takes our initial array and modify it then the data is mutable and we will loose the original reference of the array and we can have side effects ## Working with array Functions ```javascript // Returns the value of the first element in an array that pass a test users.find((u) => { return u.id === id; }); // Checks if every element in an array pass a test users.every((u) => { return u.isAdmin; }); // Checks if any of the elements in an array pass a test users.some((u) => { return u.isAdmin; }); // Creates a new array with every element in an array that pass a test users.filter((u) => { return u.isAdmin; }); // Creates a new array with the result of calling a function for each array element users.map((u) => { u.updated = new Date(); return u; }); // Reduce the values of an array to a single value (going left-to-right) users.reduce((accumulator, n) => { return accumulator + n; }, 0); ``` ## Chaining Exercise: For a given array of numer we what to: 1. reduce every value by 1. 2. summ all resulting values that are divisible by 3 Solution: **IMPERATIVE** ```javascript // given array let numbers = [2, 4, 10, 12, 19, 23]; let sum = 0; for (let i = 0; i < numbers.length; i++) { numbers[i] = numbers[i] - 1; if (numbers[i] % 3 == 0) { sum += numbers[i]; } } console.log(sum); // sum = 30; ``` **DECLARATIVE** ```javascript // given array // given array let numbers = [2, 4, 10, 12, 19, 23]; let substractOne = (n) => n - 1; let isDivisbleBy3 = (n) => (n % 3 === 0 ? n : null); let add = (n, i) => n + i; let sum = numbers.map(substractOne).filter(isDivisbleBy3).reduce(add, 0); console.log(sum); // sum = 30; ``` ## Currying Convert a function that accepts multiple parameters into a series of functions that each only take 1 parameter Let's see an example: <br> ```javascript // starting from users.find((u) => { return u.id === id; }); // now we could do soomethig like: const byId = (item) => { return item.id === id; } users.find(byId) // the problem with the above code is that id will be undefined since we need 2 params and we are passing only one // the solution will be a function that returns another function const byId = (id) => { return (item) => { return item.id === id; } } users.find(byId(2)) // So this also means that you could use byId in any place and you can call it like: byId(2)(users) // Ramda has a curry function that does currying const byId = R.curry(id, item) { return item.id === id; } users.find(byId(2)) // also de advantage of using the R.curry funtion is that it accepts more than 2 parameters // for example: const add = R.curry((a,b,c,) => { return a + b + c; }) add(1)(2)(3); ``` This is another example ```javascript const convertUnits = (toUnit, factor, offset = 0) => (input) => ((offset + input) * factor).toFixed(2).concat(toUnit); const milesToKm = convertUnits(\"km\", 1.60936, 0); const poundsToKg = convertUnits(\"kg\", 0.4546, 0); const farenheitToCelsius = convertUnits(\"degrees C\", 0.5556, -32); milesToKm(10); //\"16.09 km\" poundsToKg(2.5); //\"1.14 kg\" farenheitToCelsius(98); //\"36.67 degrees C\" const weightsInPounds = [5, 15.4, 9.8, 110]; // without currying // const weightsInKg = weightsInPounds.map(x => convertUnits('kg', 0.45460, 0)(x)); // with currying const weightsInKg = weightsInPounds.map(poundsToKg); // 2.27kg, 7.00kg, 4.46kg, 50.01kg ``` ## Partial application Supplying less arguments than required <div class=\"bibliography\"> Bibliography: - Wikipedia: https://en.wikipedia.org/wiki/Functional_programming <br> - Pluralsite video: [(Fundamentals of Functional Programming in JavaScript by Nate Taylor)](https://app.pluralsight.com/library/courses/javascript-functional-programming-fundamentals/exercise-files)<br> - w3School: [JavaScript Array Reference](https://www.w3schools.com/jsref/jsref_obj_array.asp) </div>",
    "path": "/blog/functional/functional-programming"
  },
  {
    "title": "programming functors",
    "description": "Understanding functors as a design pattern for safely manipulating wrapped values in functional programming",
    "tags": [
      "declarative",
      "Pure functions",
      "Inmutable",
      "currying"
    ],
    "categories": [
      "functional"
    ],
    "content": "> **Functor is simply an interface with a contract.**<br> > We could have just as easily named it Mappable, but now, where's the fun in that?.<br> > _Professor Frisby's_ A functor is nothing more than a data structure that you can map functions with the purpose of lifting values intro a wrapper, modifying them, and then putting them back into a wrapper. It is a design pattern that defines semantics for how **fmap** should work ` fmap :: (A -> B) -> Wrapper(A) -> Wrapper(B)` Let's see an example: ```javascript // NOTE: we can't use arrow function if we are referencing this inside the function (no \"new\" for arrow functions) var Container = function (x) { this.__value = x; }; Container.of = function (x) { return new Container(x); }; Container.of(3); // => Contaier(3) === { \"__value\": 3 } Container.of(Container.of(\"pepinillos\")); // => Container(Container(\"pepinillos\")) === { \"__value\": { \"__value\": \"pepinillos\" } } ``` - `Container` is an object with one property. - Lots of containers just hold one thing, though they aren't limited to one. We've arbitrarily named its property `__value`. - The `__value` cannot be one specific type or our `container` would hardly live up to the name. - Once data goes into the `Container` it stays there. We could get it out by using `.__value` , but that would defeat the purpose. --- So now let's recap again about the idea of a functor. What is a functor and what a functor should have. A functor will be mainly a container, and why do we want to do that?, well containerizing (or wrapping) values is a fundamental design pattern in functional programming because it **guards direct access to the values** so they can be manipulated safely and immutably in your programs. ```javascript class Wrapper { constructor(value) { this._value = value; } toString() { return \"Wrapper (\" + this._value + \")\"; } } // wrap :: A -> Wrapper(A) const wrap = (val) => new Wrapper(val); wrap(\"Hello Muzzy\").toString(); // -> Wrapper (Hellow Muzzy) ``` Now that we have a container for our values we need something to operate those values , because accessing a wrapped value can only be done by **mapping an operation to its container**. So a functor must be a wrapped object and a function to **map** over the values, in functional world they use to call this function **map** or **fmap** ```javascript class Wrapper { constructor(value) { this._value = value; } toString() { return \"Wrapper (\" + this._value + \")\"; } // map :: (A -> B) -> A -> B map(fn) { return fn(this._value); } } // wrap :: A -> Wrapper(A) const wrap = (val) => new Wrapper(val); wrap(\"Hello Muzzy\").toString(); // -> Wrapper (Hellow Muzzy) wrap(\"Hello Muzzy\").map((item) => item.toUpperCase()); // --> HELLOW MUZZY ``` In the above example we are mapping over the value but the problem is that we are returning the value transformed already , witch is ok but we cannot chain any thing else withing this container and we loose the ability to box our data because we exit our \"safe container\". So maybe a good idea will be to return the mapped result into a new wrapper instead of returning only the result. So we change our function map into an **fmap** ```javascript class Wrapper { constructor(value) { this._value = value; } toString() { return \"Wrapper (\" + this._value + \")\"; } // fmap :: (A -> B) -> Wrapper[A] -> Wrapper[B] fmap(fn) { return new Wrapper(fn(this._value)); } } // wrap :: A -> Wrapper(A) const wrap = (val) => new Wrapper(val); wrap(\"Hello Muzzy\").toString(); // -> Wrapper (Hellow Muzzy) wrap(\"Hello Muzzy\").fmap((item) => item.toUpperCase()); // --> Wrapper { _value: 'HELLO MUZZY' } ``` So now we are returning a new Wrapper object with the value transformed after applying the mapped function (toUpperCase). fmap knows how to apply functions to values wrapped in a context. It first opens the container, then applies the given function to its value, and finally closes the value back into a new container of the **same type**. This allows us to chain more actions within our wrapped value. So imagine that we want to upper case and then split words into an array, we could easily do: ```javascript class Wrapper { constructor(value) { this._value = value; } toString() { return \"Wrapper (\" + this._value + \")\"; } // fmap :: (A -> B) -> Wrapper[A] -> Wrapper[B] fmap(fn) { return new Wrapper(fn(this._value)); } } // wrap :: A -> Wrapper(A) const wrap = (val) => new Wrapper(val); wrap(\"Hello Muzzy\") .fmap((item) => item.toUpperCase()) .fmap((item) => item.split(\" \")); // --> Wrapper { _value: [ 'HELLO', 'MUZZY' ] } ``` Then after having an fmap function that returns the same type object we can also state that a functor will follow these two rules: 1. **Preserves identity** ```javascript object.fmap(x => x) ≍ object ``` 2. **Composable** ```javascript object.fmap(compose(f, g)) ≍ object.fmap(g).fmap(f) ``` <br> An finally we can say then that an object will be a functor if it fulfills these rules: **1) It is a wrapper object to contain our data**<br> **2) had a map function to iterate over its own data**<br> **3) preserves identity**<br> **4) can be composable**<br><br> <hr> <div class=\"bibliography\"> Bibliogrphy:<br><br> - Functional Programming in JavaScript . Ed: MANNING SHELTER ISLAND. Author: Luis Atencio. - [Mostly Adequate Guide to functional programming](https://drboolean.gitbooks.io/mostly-adequate-guide-old/content/). Professor Frisby's<br> </div>",
    "path": "/blog/functional/functors"
  },
  {
    "title": "Memoize",
    "description": "A more function memoizer",
    "tags": [
      "declarative",
      "Pure functions",
      "Inmutable",
      "currying",
      "functors"
    ],
    "categories": [
      "functional"
    ],
    "content": "```javascript // A more functional memoizer //We can beef up our module by adding functions later var Memoizer = (function () { //Private data var cache = {}; //named functions are awesome! function cacher(func) { return function () { var key = JSON.stringify(arguments); if (cache[key]) { return cache[key]; } else { val = func.apply(this, arguments); cache[key] = val; return val; } }; } //Public data return { memo: function (func) { return cacher(func); }, }; })(); var fib = Memoizer.memo(function (n) { if (n < 2) { return 1; } else { return fib(n - 2) + fib(n - 1); } }); ```",
    "path": "/blog/functional/memoize"
  },
  {
    "title": "monads",
    "description": "Exploring monads as specialized functors for handling null data and streamlining error handling in functional programming",
    "tags": [
      "declarative",
      "Pure functions",
      "Inmutable",
      "currying",
      "functors"
    ],
    "categories": [
      "functional"
    ],
    "content": "So let's remember first what's a functor: 1. It is a wrapper object to contain our data 2. had a map function to iterate over its own data 3. preserves identity 4. can be composable But functors by themselves aren't compelling, because they're not expected to know how to handle cases with **null data**.<br> `Ramda's R.compose`, for instance, will break if a null function reference is passed into it. This isn't a flaw in the design; it's intentional. - Functors map functions of one type to another. - More-specialized behavior can be found in functional data types called monads. - Among other things, monads can streamline error handling in your code,allowing you to write fluent function compositions. - What's their relationship to functors? **Monads are the containers that functors \"reach into.\"**",
    "path": "/blog/functional/monads"
  },
  {
    "title": "transducers",
    "description": "Exploring transducers in functional programming for efficient data transformation pipelines without creating intermediate values",
    "tags": [
      "declarative",
      "Pure functions",
      "Inmutable",
      "currying",
      "functors",
      "transducers"
    ],
    "categories": [
      "functional"
    ],
    "content": "The primary goal of transducers is to run a pipeline of transformations of an input stream of values **without creating intermediate values**. The functions describing computations are decoupled, so this makes program design cleaner and easier to develop and maintain. A transducer is a function that accepts a transformer and returns a transformer and can be composed directly Transducers can: - Be Composable - They only enumerates over the elements **onces** (very efficient for working with data streams) - can be use for lazy or eager evaluation - You can combine transducer to generate another transducer (High order reducers ¿?) There are two strategies: - **Pull:** lazy evaluation - **Push:** eager evaluation **Pull** waits until a consumer asks for the next value (for example an Iterable) **Push** enumerates over the source values and pushes them through the tubes ASAP (Array.reduce()) Transducers compose top to bottom (left to right) **Example:** Given an array of autobots we want to: 1. ﬁlter out values that don't contain the letter 'r', 2. uppercase 3. reverse each value **First approach without a tranducer** ```javascript const R = require(\"ramda\"); // Ramda functional library let autobots = [ \"Optimus Prime\", \"Bumblebee\", \"Ironhide\", \"Sunstreaker\", \"Ratchet\", ]; // Filter for autobots that contain 'r', uppercase, then reverse let transform = R.compose( R.filter((x) => /r/i.test(x)), R.map(R.toUpper), R.map(R.reverse) ); transform(autobots); // => [ 'EMIRP SUMITPO', 'EDIHNORI', 'REKAERTSNUS', 'TEHCTAR' ] ``` **Same approach with tranducer** ```javascript const R = require(\"ramda\"); // Ramda functional library let autobots = [ \"Optimus Prime\", \"Bumblebee\", \"Ironhide\", \"Sunstreaker\", \"Ratchet\", ]; // Filter for autobots that contain 'r', uppercase, then reverse let transform = R.compose( R.filter((x) => /r/i.test(x)), R.map(R.toUpper), R.map(R.reverse) ); transform(autobots); // => [ 'EMIRP SUMITPO', 'EDIHNORI', 'REKAERTSNUS', 'TEHCTAR' ] ``` We get the same exact result (in this situation), but something very different and very powerful is happening under the hood. **In the first example, the entire list was transformed at each step**.<br> This means that we had to iterate over the list three times. However, **in the second example** where we used the transducer, **we only had to iterate over the list once!** <div class=\"bibliography\"> Bibliogrphy:<br><br> - [effectfulJS](https://github.com/awto/effectfuljs/tree/master/packages/transducers) - [Understanding Transducers in JavaScript](https://medium.com/@roman01la/understanding-transducers-in-javascript-3500d3bd9624) - [MAGICAL, MYSTICAL JAVASCRIPT TRANSDUCERS](https://jrsinclair.com/articles/2019/magical-mystical-js-transducers/) - [Transducers: Efficient Data Processing Pipelines in JavaScript](https://medium.com/javascript-scene/transducers-efficient-data-processing-pipelines-in-javascript-7985330fe73d). </div>",
    "path": "/blog/functional/transducers"
  },
  {
    "title": "Global variables are bad",
    "description": "Exploring the dangers of global variables in JavaScript, including scope pollution, concurrency issues, and best practices for variable declaration",
    "tags": [
      "javascript",
      "globals"
    ],
    "categories": [
      "javascript"
    ],
    "content": "## Extracted from a Gist, a very nice explanation ```javascript // It is important to declare your variables. (function() { var foo = 'Hello, world!'; print(foo); //=> Hello, world! })(); print(foo); // No way José !! // Because if you don't, the become global variables. (function() { foo = 'Hello, world!'; print(foo) //=> Hello, world! })(); print(foo) //=> WTF, it returns \"Hello, world!\" // When global variables sneak into your code they can cause problems. // Especially in applications with concurrency. var count = function() { for (i = 0; i < 10; i += 1) { print(i); } }; count(); //=> 0 1 2 3 4 5 6 7 8 9 var countSilently = function() { for (i = 0; i < 10; i += 1) { // don't print anything; } }; // Both loops increment i at the same time, which causes strange behavior. window.setTimeout(countSilently, 10); window.setTimeout(count, 10); //=> 2 3 7 8 9 // You can use 'this' in method definitions to refer to attributes of the // method's object. var obj = { name: 'foo', introduce: function() { print(this.name); } }; obj.introduce(); //=> foo // But 'this' does not follow the normal rules of scope in JavaScript. One // might expect 'this' to be available with the same value via closure in the // callback defined inside the method here. var obj = { name: 'foo', introduce: function() { window.setTimeout(function() { print(this.name); }, 3000); } }; obj.introduce(); //=> *pause* undefined // In fact, this got bound to the global object in the callback. To get around // this, assign the object reference to a regular variable that will have the // same value inside the callback definition. var obj = { name: 'foo', introduce: function() { var that = this; window.setTimeout(function() { print(that.name); }, 3000); } }; obj.introduce(); //=> *pause* foo // The keyword 'this' is actually dynamically assigned whenever a function is // invoked. When a function is invoked as a method, i.e. obj.method(), 'this' // is bound to 'obj'. But when a function is invoked by itself 'this' is bound // to the global object. var phrase = 'Hello, world!'; var printPhrase() { print(this.phrase); } printPhrase(); //=> Hello, world! // This is true even of functions that were defined as a method. var obj = { name: 'foo', introduce: function() { print(this.name); } }; // When the function is invoked without 'obj.' in front of it, 'this' becomes // the global namespace. var introduce = obj.introduce; introduce(); //=> undefined // Method invocation and function invocation are two of the invocation patterns // in JavaScript. A third is apply invocation, which gives us control over what // 'this' will be assigned to during function execution. introduce.apply(obj, null); //=> foo // 'apply' is a method on Function. The first argument is the value that 'this' // will be bound to. Successive arguments to apply are passed as arguments to // the function that is being invoked. var chatty = function(repeatTimes) { var i; for (i = 0; i < repeatTimes; i += 1) { print(this.name + ' '); } } chatty.apply(obj, 3) //=> foo foo foo // The fourth and final invocation pattern in JavaScript is constructor // invocation. This pattern was designed to provide a way to create new objects // that would appear familiar to programmers who are used to programming with // classes. var Cat = function(name) { this.name = name; }; Cat.prototype = { query: function() { print(this.name + ' says, \"meow\"'); } }; // When a function is called with the 'new' keyword in front of it, a new // object is created and is bound to 'this' when the function runs. Special // constructor functions use this feature to customize new objects as they are // created. var whiskers = new Cat('whiskers'); whiskers.query(); //=> whiskers says \"meow\" // When a new object is created with 'new', the prototype of the new object is // set to the prototype of the constructor function. So the new object inherits // all of the attributes of the constructor's prototype value. In this case, // new cat objects inherit the 'query' method from Cat.prototype. var nibbler = new Cat('nibbler'); nibbler.query(); //=> nibbler says \"meow\" // If a constructor function is called without the 'new' keyword, it is invoked // with the ordinary function invocation pattern. var gotcha = Cat('gotcha!'); gotcha.query(); //=> typein:165: TypeError: gotcha has no properties // So 'this' is assigned to the global object instead of to a newly created object. That means that any attributes assigned to the new object by the constructor function become global variables! print(name); //=> gotcha! // Constructor invocation is pretty complicated and prone to disastrous global // variable creation. Here is a cleaner way to create new objects that inherit // from other objects. // This defines Object.create, a method that simplifies the behavior of the // 'new' keyword. This method was invented by Douglas Crockford. // http://javascript.crockford.com/prototypal.html if (typeof Object.create !== 'function') { Object.create = function(o) { var F = function() {}; F.prototype = o; return new F(); }; } // Object.create(obj) returns a new object that inherits all of the attributes // of obj. The 'cat' prototype object here defines a 'clone' method that wraps // around Object.create to customize new 'cat' objects as they are created. var cat = { query: function() { print(this.name + ' says \"meow\"'); }, clone: function(name) { var newCat = Object.create(this); newCat.name = name; return newCat; } }; var fluffy = cat.clone('fluffy'); fluffy.query(); //=> fluffy says \"meow\" // In addition to inheriting 'query', new cats also inherit 'clone'. var fluffy2 = fluffy.clone('fluffy2'); fluffy2.query(); //=> fluffy2 says \"meow\" // Methods and attributes are inherited, not copied. If you change the // definition of 'clone' on 'cat' at this point, the change will be reflected // in cat objects that have already been created. fluffy2.hasOwnProperty('clone') //=> false fluffy.hasOwnProperty('clone') //=> false cat.hasOwnProperty('clone') //=> true ``` <br> Bibliography:<br> https://gist.github.com/hallettj/64478",
    "path": "/blog/global-variables-are-bad"
  },
  {
    "title": "Lexical and Dynamic scope",
    "description": "Understanding lexical and dynamic scoping in JavaScript, including the eval keyword and its performance implications",
    "tags": [
      "scope",
      "eval",
      "javascript"
    ],
    "categories": [
      "javascript"
    ],
    "content": "# Lexical scoping ## Evil eval We can cheat on lexical scoping using eval keywod. <br> The eval keyword, takes any given strings and it treats as it was a code ```javascript var bar = \"foo\"; function foo(str) { eval(str); console.log(\"bar\"); // 42 !!!!! } foo(\"var bar = 42\"); ``` The problem of doing this is that performance will be afected because as we know JS first assign the LHS (left hand side), witch means that it will read all the assigments on the left and lator will do the right hand side of the code. In the case of the eval function we are using a RHS that contains a LHS and RHS statement and that means that JS compiler will not be able to do a code optimization because the engine cannot assume the lexical scoping to be unchange. So even if we declare an eval and not using it to do a declaration it will have a side effect on perfomance in our code.<br> So to summarize in general we should not use eval key ## with with We can also skeep lexical scope by doing even a worse thing and that is using the with statement ## A note about LHS and RHS LHS look-up is done when a variable appears on the left-hand side of an assignment operation, and an RHS look-up is done when a variable appears on the right-hand side of an assignment operation. I think of it as follows :<br> lhs lookup is a container lookup <br> rhs lookup is a value lookup<br> # Dynamic scope ### Bibliograpy:<br> https://stackoverflow.com/questions/36383795/javascript-lhs-and-rhs-lookup Plural sight course: Advanced javascript, by kyle Simpson",
    "path": "/blog/lexical-and-dynamic-scope"
  },
  {
    "title": "Method chaining in javascript",
    "description": "Understanding method chaining in JavaScript for creating fluent interfaces and improving code readability through sequential method calls",
    "tags": [
      "javascript",
      "method chaining"
    ],
    "categories": [
      "javascript"
    ],
    "content": "# Method chaining in Javascript from [wikipedia](https://en.wikipedia.org/wiki/Method_chaining) <br> Method chaining, also known as named parameter idiom, is a common syntax for invoking multiple method calls in object-oriented programming languages. The key to achieve this is that each method returns an object, allowing the calls to be chained together in a single statement without requiring variables to store the intermediate results. A similar syntax is method cascading, where after the method call the expression evaluates to the current object, not the return value of the method. Cascading can be implemented using method chaining by having the method return the current object itself. Cascading is a key technique in fluent interfaces, and since chaining is widely implemented in object-oriented languages while cascading isn't, this form of \"cascading-by-chaining by returning this\" is often referred to simply as \"chaining\". Both chaining and cascading come from the Smalltalk language. While chaining is syntax, it has semantic consequences, namely that requires methods to return an object, and if implementing cascading via chaining, this must be the current object. This prevents the return value from being used for some other purpose, such as returning an error value. To see an example lest first define our use case: Imagine that we have a class person that has some methods (or functions), these are: ```javascript setName(); setEyeColor(); setHairColor(); setHeight(); ``` And this is the definition of our class ```javascript // Definition of the class // ------------------------ class Person { constructor() { console.log(\"person created\"); } setName(name) { this.name = name; } setEyeColor(eyeColor) { this.eyeColor = eyeColor; } setHairColor(hairColor) { this.HairColor = hairColor; } setHeight(height) { this.height = height; } } ``` Now if we want to create a person and execute all methods we will do : ```javascript // Execution // --------- var pers = new Person(); pers.setName(\"Joe\"); pers.setEyeColor(\"blue\"); pers.setHairColor(\"black\"); pers.setHeight(\"1.75\"); console.log(pers); ``` So far so good. But this could be improved doing method chaining. This way we will remove the call of pers object every time we want to execute a function of that object. <br/ >So our execution will be something like this: ```javascript var pers = new Person() .setName(\"Joe\") .setEyeColor(\"blue\") .setHairColor(\"black\") .setHeight(\"1.75\"); console.log(pers); ``` Or better yet, we can apply some formating and also we don't even need to assign a var to person since we are doing method chaining , rewriting the above syntax as: ```javascript console.log( new Person() .setName(\"Joe\") .setEyeColor(\"blue\") .setHairColor(\"black\") .setHeight(\"1.75\") ); ``` The problem comes now because if we execute the above sentence we will end up with a compiler error. This is because when we create a new person, none of the methods that we previously define are returning a value, so after the first method call the compiler does not know in what object to execute the next function. To solve this we will need to redefine our methods to return the same object, like this ```javascript class Person { constructor() { console.log(\"person created\"); } setName(name) { this.name = name; return this; } setEyeColor(eyeColor) { this.eyeColor = eyeColor; return this; } setHairColor(hairColor) { this.HairColor = hairColor; return this; } setHeight(height) { this.height = height; return this; } } ``` And now we can do method chaining. ```javascript console.log( new Person() .setName(\"Dina\") .setEyeColor(\"black\") .setHairColor(\"brown\") .setHeight(\"1.85\") ); // Person {HairColor:\"brown\", eyeColor:\"black\", height:\"1.85\", name:\"Dina\"} ```",
    "path": "/blog/method-chaining-in-javascript"
  },
  {
    "title": "Object attribute properties",
    "description": "Exploring JavaScript object property attributes including value, configurable, enumerable, and writable flags",
    "tags": [
      "javascript",
      "object properties"
    ],
    "categories": [
      "javascript"
    ],
    "content": "Atributos de las propiedades Cada una de las propiedades tiene 4 atributos, los cuales son value configurable enumerable writable Bibliography <br> [Yeison Daza](https://medium.com/entendiendo-javascript/entendiendo-los-objetos-en-javascript-3a6d3a0695e5)",
    "path": "/blog/object-atribute-properties"
  },
  {
    "title": "IIFE",
    "description": "Understanding Immediately Invoked Function Expressions (IIFE) in JavaScript and their use in preventing global scope pollution",
    "tags": [
      "design patterns",
      "IIFE"
    ],
    "categories": [
      "design patterns"
    ],
    "content": "# IIFE - Iimmediatelly Invoked Function Expression ```javascript var foo = \"foo1\"; (function () { var foo = \"foo2\"; console.log(foo); // foo2 })(); console.log(foo); // foo1 // we can also write the above statement like: (function () { // code })(); ``` We use IIFE in order to not pollute the global scope. <div class=\"bibliography\"> Bibliography: <br/><br/> - Ben Alman: [Immediately-Invoked Function Expression (IIFE)](http://benalman.com/news/2010/11/immediately-invoked-function-expression/) </div>",
    "path": "/blog/patterns/iife"
  },
  {
    "title": "Mixins",
    "description": "Understanding mixins in JavaScript as a solution for multi-inheritance, including delegation, concatenative, and functional inheritance patterns",
    "tags": [
      "design patterns",
      "mixins",
      "functional mixins",
      "inherence"
    ],
    "categories": [
      "design patterns"
    ],
    "content": "In JavaScript we can only inherit from a single object. There can be only one **[[Prototype]]** for an object. And a class may extend only one other class. **To solve the use of multi inheritance we use mixins**. In object-oriented programming languages, a Mixin is a class that contains methods for use by other classes without having to be the parent class of those other classes. A mixin can also be viewed as an **interface with implemented methods**. This pattern is an example of enforcing the [**dependency inversion principle**](https://en.wikipedia.org/wiki/Dependency_inversion_principle). ## Inheriting \"methods\" JavaScript does not have methods in the form that class-based languages define them. **In JavaScript, any function can be added to an object in the form of a property**. An inherited function acts just as any other property, including property shadowing There is more than one type of prototypal inheritance: - **Delegation** (i.e., the prototype chain). - **Concatenative** (i.e. mixins, `Object.assign()`). - **Functional** (Not to be confused with functional programming. A function used to create a closure for private state/encapsulation). Each type of prototypal inheritance has its own set of use-cases, but all of them are equally useful in their ability to enable composition, which creates **has-a** or **uses-a** or **can-do** relationships as opposed to the is-a relationship created with class inheritance. ## Delegation We can work with delegation by using apply, bind or call to inherit from another object. Let's see an example: <br> ```javascript function Product(name, price) { this.name = name; this.price = price; } function Food(name, price) { Product.call(this, name, price); this.category = \"food\"; } function Toy(name, price) { Product.call(this, name, price); this.category = \"toy\"; } var cheese = new Food(\"feta\", 5); var fun = new Toy(\"robot\", 40); ``` <a href=\"../testing-protoype-inheritance/\" target=\"_self\">This is another \"tricky\" example </a> ## Concatenative **Using Object.assign() as mixin** ```javascript // mixin let sayHiMixin = { sayHi() { alert(`Hello ${this.name}`); }, sayBye() { alert(`Bye ${this.name}`); }, }; // usage: const User = function (name) { this.name = name; }; // copy the methods Object.assign(User.prototype, sayHiMixin); // now User can say hi new User(\"Dude\").sayHi(); // Hello Dude! ``` **or if you were using classes you could do something like this:** ```javascript class User extends Person { // ... } Object.assign(User.prototype, sayHiMixin); ``` ###Functional Mixins If the functions defined by mixins are intended solely for the use of other objects, why bother creating mixins as regular objects at all? Put another way, a **mixin should be a process not an object**. The logical conclusion is to make our mixins into functions into which consumer objects inject themselves by delegation, thus cutting out the middle guy (the extend function) entirely. ```javascript var asCircle = function () { this.area = function () { return Math.PI * this.radius * this.radius; }; this.grow = function () { this.radius++; }; this.shrink = function () { this.radius--; }; return this; }; var Circle = function (radius) { this.radius = radius; }; asCircle.call(Circle.prototype); var circle1 = new Circle(5); circle1.area(); //78.54 ``` **Mixins as verbs instead of nouns** ### Adding Options This functional strategy also allows the borrowed behaviours to be parameterized by means of an options argument. ```javascript var asOval = function ({ growBy, shrinkBy }) { this.area = function () { /* ... */ }; this.ratio = function () { /* ...*/ }; this.grow = function () { this.shortRadius += growBy / this.ratio(); this.longRadius += growBy; }; // ... return this; }; var OvalButton = function (/*...*/) { //... }; // ... asOval.call(OvalButton.prototype, { growBy: 2, shrinkBy: 2 }); ``` **Further reading [Traits](https://github.com/traitsjs/traits.js)** Bibliography: <br> [Angus Croll](https://javascriptweblog.wordpress.com/2011/05/31/a-fresh-look-at-javascript-mixins/?blogsub=confirming%23subscribe-blog]) <br/> [javascript.info](https://javascript.info/mixins)<br/> [Wikipedia](https://en.wikipedia.org/wiki/Mixin)<br/> [Eric Elliott](https://medium.com/javascript-scene/10-interview-questions-every-javascript-developer-should-know-6fa6bdf5ad95)<br/> [developer.mozilla](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain)<br/>",
    "path": "/blog/patterns/mixins"
  },
  {
    "title": "testing prototype inheritance",
    "description": "Exploring prototype inheritance in JavaScript using the call method to inherit properties and methods between objects and functions",
    "tags": [
      "design patterns",
      "prototype",
      "inheritance"
    ],
    "categories": [
      "design patterns"
    ],
    "content": "https://stackoverflow.com/questions/53406070/using-call-to-inherit-objects-from-a-function ```js // testing Call to inherit objects / functions // ------------------------------------------- // we declare our first function const funcA = function (firstName) { this.firstName = firstName; this.getFirstName = function () { return \"My name is \" + this.firstName; }; return this; }; // Create an object out of that function const objA = new funcA(\"Rodrigo\"); // declare second function const funcB = function (lastName) { this.lastName = lastName; this.getLastName = function () { return \"My last name is \" + this.lastName; }; return this; }; // Create an Object from funcB and ObjectA const objC = funcB.call(objA, \"Erades\"); // We get an object console.log(\"TYPE OF: \", typeof objC); console.log(\"raw:\", objC); console.log(\"method A: \", objC.getFirstName()); console.log(\"prop A: \", objC.firstName); console.log(\"method B: \", objC.getLastName()); console.log(\"prop B: \", objC.lastName); console.log(\"------------\"); // if we don't want to create an object out of a function and an object, // we could also inherit two functions, but the result really surprise me const funcC = funcB.call(funcA, \"Alonso\"); // We get a function !!!!! console.log(\"TYPE OF: \", typeof funcC); console.log(\"raw:\", funcC); // To get result we need to do this: console.log(\"method ==>: \", funcC(\"Rui\")); console.log(\"method A: \", funcC(\"Rui\").getFirstName()); console.log(\"prop A: \", funcC(\"Maria\").firstName); console.log(\"method B: \", funcC.getLastName()); console.log(\"prop B: \", funcC.lastName); console.log(\"------------\"); ```",
    "path": "/blog/patterns/testing-protoype-inheritance"
  },
  {
    "title": "statement branching Vs micro-branching",
    "description": "Comparing traditional statement branching with micro-branching techniques in JavaScript for more maintainable and functional code",
    "tags": [
      "statement brnaching",
      "micro-branching strategies"
    ],
    "categories": [
      "javascript",
      "functional"
    ],
    "content": "## statement branching Any construct that alters the sequence of statement execution within the global or functional scope. <br> These include:<br> ``` if else switch for while ``` Statements are designed to execute non-linearly. Aside from the obvious bloating effect, statement branching tends to become unintuitive as it progresses. ## micro-branching Conditional logic contained within a statement that has no effect on the statement execution seqeunce.<br> The following operators facilitate micro-branching: <br> ``` ternary (<cond> ? a : b) && || ``` The logic flows sequentially from top to bottom and even from left to right. There are no forks in the road. There is only one return statement and its at the bottom where we expect it. Best of all it's short. Nothing is wasted. In fact it's terse enough to be barely procedural at all. Alternatives to statement branching fall into two broad categories: **micro-branching** and **no branching at all** ## Micro-branching strategies ### Guards (&&) and Defaults(||) ```javascript //invoke callback if there is one callback && callback(); //delay by argument or 20 delayBy(delay || 20); //remove node from its parent node && node.parent && node.parent.removeChild(node); //log a test in the console id we have one window.console && console.log(\"test\"); ``` <br> <blockquote> Some things just have a natural place. Birds in the sky, fish in the sea and a return statement at the end of a function.</blockquote> <br> Bibliography:<br> https://javascriptweblog.wordpress.com/2010/07/26/no-more-ifs-alternatives-to-statement-branching-in-javascript/",
    "path": "/blog/statement-branching-vs-micro-branching"
  }
]