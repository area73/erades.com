[
  {
    "title": "particle system",
    "pubDate": "2019-01-11",
    "description": "Exploring particle system animation techniques using Canvas and JavaScript for creating dynamic visual effects",
    "tags": [
      "particle system"
    ],
    "categories": [
      "experiment"
    ],
    "draft": true,
    "heroImage": "/blog-placeholder-11.jpg",
    "content": "\n<script type=\"module\" src=\"/js/experiments/system01.js\"></script>\n\n<canvas></canvas>\n",
    "path": "/blog/experiments/particle-system-01",
    "id": "0"
  },
  {
    "title": "Hindley-Milner notation",
    "description": "Understanding Hindley-Milner type notation in functional programming for expressing function signatures and type relationships",
    "pubDate": "2019-04-11",
    "tags": [
      "declarative",
      "Pure functions",
      "Inmutable",
      "currying",
      "Hindley-Milner"
    ],
    "categories": [
      "functional"
    ],
    "draft": false,
    "heroImage": "/blog-placeholder-13.jpg",
    "content": "\nA way to create a notation to express what types of parameter a function takes, and what it returns.\n\n## The basic\n\nA function that takes a primary value (\"old type\" like string, number, boolean, array, function...) and returns another primary value:\n\n`instruction :: String -> String`\n\n```javascript\nconst instruction = function (verb) {\n  return verb + \" me\";\n};\n```\n\nthe function instruction takes a string and return a string\n\nYou could also do something like:\n\n`length :: String → Number`\n\n```javascript\nconst length = function (s) {\n  return s.length;\n};\n```\n\nIn the case of an array of numbers:\n\n`length :: [Number] → Number`\n\n```javascript\n    const length = function(arr){\n        retrun arr.length\n    }\n```\n\n## Working with functions\n\nIn the case of a function, we wrap our function in parenthesis and inside the parenthesis we have our input type and our output type:\n\n`addOneToAll :: ((Number → Number),[Number]) → [Number]`\n\n```javascript\nconst addOne = function (x) {\n  return x + 1;\n};\nconst addOneToAll = (addOne, arr) => arr.map(addOne);\n```\n\nIn this case we have a function call addOneToAll that expects as first parameter a function (in our case addOne) and this function will accept a number and returns a nunmber.\nAnd as a second parameter an array of numers and will return another array of numbers.\n\n### Currying functions\n\nNow what about a function that returns a function that returns another function ....\n\nFollowing above we will have something like this:\n`replace :: String -> (String -> (String -> String))`\n\n```javascript\nvar replace = curry(function (find, replacement, str) {\n  var regex = new RegExp(find, \"g\");\n  return str.replace(regex, replacement);\n});\n```\n\nIn this case we also curryfy the function in order to take parameters one by one\n\nAnd in functional programming we can assuming that everything is curried, so we tend to drop the brackets and something like this:\n\n` replace :: String -> String -> String -> String`\n\n## Working with functions that takes multiple parameters as input (Hindley-Milner's Arbitrary Variables)\n\nWe show the example with the length function were we could have:\n`length :: [Number] → Number`\nor\n`length :: string → Number`\n\nIn this case we could write both with an arbitrary variable like:\n`length :: [a] → Number`\n\nAnother common example is the identity:\n`identity :: a -> a`\n\nAnd a more complex example:\n`map :: (a -> b) -> [a] -> [b]`\n\n```javascript\nconst map = curry(function (callback, array) {\n  return array.map(callback);\n});\n```\n\nThe map function takes a function that takes a variable of type `a` and returns a variable of type `b`.\nThen takes an **array of values**, all type `a`, and returns an **array of values**, all type `b`.\n\n---\n\n## Working with Ramda\n\n## Parametrized Types\n\nWe can easily imagine a type representing a collection of similar items,\nlet's call it a Box. But no instance is an arbitrary Box; each one can only hold one sort of item.\n\n`makeBox :: Number -> Number -> Number -> [a] -> Box a`\n\n```javascript\n  const makeBox = curry((height, width, depth, items) => /* ... */);\n```\n\n## Type Aliases\n\nIf we had a parameterized type User String, where the String was meant to represent a name, and we wanted to be more specific about the type of String that is represented when generating a URL, we could create a type alias like this:\n\n`toUrl :: User Name u => Url -> u -> Url`\n\n`Name = String`\n\n` Url = String`\n\n```javascript\nconst toUrl = curry(\n  (base, user) => base + user.name.toLowerCase().replace(/\\W/g, \"-\")\n);\ntoUrl(\"http://example.com/users/\", { name: \"Fred Flintstone\", age: 24 });\n//=> 'http://example.com/users/fred-flintstone'\n```\n\n## Type constrains [Ord]\n\nSometimes we want to restrict the generic types we can use in a signature in some way or another\n\nWe might want a maximum function that can operate on Numbers, on Strings, on Dates, but not on arbitrary Objects.\n\nWe want to describe ordered types, ones for which **a < b will always return a meaningful result**\n\n`maximum :: Ord a => [a] -> a`\n\n```javascript\nconst maximum = (vals) =>\n  reduce((curr, next) => (next > curr ? next : curr), head(vals), tail(vals));\nmaximum([3, 1, 4, 1]); //=> 4\nmaximum([\"foo\", \"bar\", \"baz\", \"qux\", \"quux\"]); //=> 'qux'\nmaximum([\n  new Date(\"1867-07-01\"),\n  new Date(\"1810-09-16\"),\n  new Date(\"1776-07-04\"),\n]); //=> new Date(\"1867-07-01\")\n```\n\n`Ord a ⇒ [a] → a` says that maximum takes a collection of elements of some type, but that type must adhere to Ord.\n\nIn JS, there's no way to guarantee that the user will not pass us [1, 2, 'a', false, undefined, null].\nSo our entire type annotation is **descriptive and aspirational** rather than compiler-enforced, as it would be in, say, Haskell.\n\n## Multiple Signatures\n\nSometimes rather than trying to find the most generic version of a signature, it's more straightforward to list several related signatures separately.\nWe could do that like bellow:\n\n`getIndex :: a -> [a] -> Number`\n`         :: String -> String -> Number`\n\n```javascript\nconst getIndex = curry((needle, haystack) => haystack.indexOf(needle));\ngetIndex(\"ba\", \"foobar\"); //=> 3\ngetIndex(42, [7, 14, 21, 28, 35, 42, 49]); //=> 5\n```\n\n## Variadic Functions (specific to Ramda)\n\nIn Haskell, all functions have a fixed arity. But Javsacript has to deal with variadic functions.\n`flip :: (a -> b -> ... -> z) -> (b -> a -> ... -> z)`\n\n```javascript\nconst flip = (fn) =>\n  function (b, a) {\n    return fn.apply(this, [a, b].concat([].slice.call(arguments, 2)));\n  };\nflip((x, y, z) => x + y + z)(\"a\", \"b\", \"c\"); //=> 'bac'\n```\n\n## Simple Objects\n\nWhen an object is used as a dictionary of like-typed values (as opposed to its other role as a Record), then the types of the keys and the values can become relevant.\nSo we could represent them like this:\n`keys :: {k: v} -> [k]`\n`values :: {k: v} ->  [v]`\n\n```javascript\nkeys({ a: 86, b: 75, c: 309 }); //=> ['a', 'b', 'c']\nvalues({ a: 86, b: 75, c: 309 }); //=> [86, 75, 309]\n```\n\n## Complex example\n\n`Lens s a -> (a -> a) -> s -> s`\n`Lens s a = Functor f => (a -> f a) -> s -> f s`\n\nWe start with the type alias, Lens s a = Functor f ⇒ (a → f a) → s → f s.\nThis tells us that the type Lens **is parameterized by two generic variables, s, and a**.\nWe know that there is a constraint on the type of the f variable used in a Lens: **it must be a Functor**.\nWith that in mind, we see that a Lens is a curried function of two parameters, the first being a function from\na value of the generic type a to one of the parameterized type f a, and the second being a value of generic type s.\n\n**The result** is a value of the parameterized type `f・s`\n\n<div class=\"bibliography\">\nBibliogrphy:<br><br>\n\n- [gentle introduction to functional javascript style](https://jrsinclair.com/articles/2016/gentle-introduction-to-functional-javascript-style#hindley-milnertypesignatures)\n- [function type signatures in Javascript](https://hackernoon.com/function-type-signatures-in-javascript-5c698c1e9801)\n- [Type signatures in Ramda](https://github.com/ramda/ramda/wiki/Type-Signatures)\n</div>\n",
    "path": "/blog/functional/hindley-milner-notation",
    "id": "1"
  },
  {
    "title": "combinators",
    "description": "Understanding combinators in functional programming as higher-order pure functions for composing and controlling program flow",
    "pubDate": "2019-01-10",
    "tags": [
      "declarative",
      "Pure functions",
      "Inmutable",
      "currying",
      "combinator"
    ],
    "categories": [
      "functional"
    ],
    "draft": false,
    "heroImage": "/blog-placeholder-10.jpg",
    "content": "\nA combinator are higher-order , **pure functions** that doesn't have any **free variable** and\ncan combine primitive artifacts like other functions (or other combinators) and behave as control logic.\n\n**Free variables** are just simple variables in the context of a function that aren't explicit\npass in as argument.\n\nOur commitment is that all dependencies are pass by parameter.\n\nCombinators unlock freedom and facilitate point-free programming.\nBecause combinators are pure, they can be composed into other combinators,\nproviding an infinite number of alternatives to express and reduce the complexity of writing\nany type of application.\n\nFor example a composer function will be a combinator:\n\n```javascript\nconst compose = (f, g) => (x) => f(g(x));\n\nconst addTwo = (x) => x + 2;\nconst multByTree = (x) => x * 3;\n\nconst operator = compose(addTwo, multByTree);\n\nconsole.log(operator(7)); // 23\n// NOTE: remember that  compose will execute from right to left\n```\n\nIn Ramda there are many combinators that we can use:\n\n- compose\n- pipe\n- identity\n- tap\n- alternation\n- sequence\n- fork (join)\n\n## identity\n\nThe identity combinator is a function that returns the same value it was provided as an argument:\n\n`identity :: (a) -> a`\n\nIt's used extensively when examining the mathematical properties of functions,\nbut it has other practical applications as well:\n\n- Supplying data to higher-order functions that expect it when evaluating a function argument.\n- Unit testing the flow of function combinators where you need a simple function result on which\n  to make assertions.\n- Extracting data functionally from encapsulated types.\n\n## Tap\n\ntap is extremely useful to bridge void functions (such as logging or writing a file or an HTML page)\ninto your composition without having to any create additional code. It does this by passing itself\ninto a function and returning itself. Here's the function signature:\n\n`tap :: (a -> *) -> a -> a`\n\n## Alternation [OR - combinator]\n\nThe alt combinator allows you to perform **simple conditional logic** when providing default\nbehavior in response to a function call.\nThis combinator takes two functions and returns the result of the first one if the value is\ndefined (not false, null, or undefined); otherwise, it returns the result of the second function.\n\n## Sequence (S-combinator)\n\nThe seq combinator is used to loop over a sequence of functions. It takes two or more functions\nas parameters and returns a new function, which runs all of them in sequence against the same value.\n\nThe seq combinator doesn't return a value; it just performs a set of actions one after the other.\n\n## Fork (join) combinator\n\nThe fork combinator is useful in cases where you need to process a single resource in two\ndifferent ways and then combine the results.\n\n<br><br>\n\n<div class=\"bibliography\">\nBibliography:<br>\n\n- Functional Programming in JavaScript . Ed: MANNING SHELTER ISLAND. Author: Luis Atencio.<br>\n- [Mostly Adequate Guide to functional programming](https://drboolean.gitbooks.io/mostly-adequate-guide-old/content/).\n  Professor Frisby's<br>\n- [Building a declarative app using Functional javaScript](https://www.packtpub.com/web-development/building-declarative-apps-using-functional-javascript-video).\n  Michael Rosata\n  </div>\n",
    "path": "/blog/functional/combinators",
    "id": "2"
  },
  {
    "title": "functional programming",
    "description": "An introduction to functional programming concepts including declarative programming, pure functions, immutability, and currying",
    "pubDate": "2018-01-12",
    "tags": [
      "declarative",
      "Pure functions",
      "Inmutable",
      "currying"
    ],
    "categories": [
      "functional"
    ],
    "draft": false,
    "heroImage": "/blog-placeholder-12.jpg",
    "content": "\nIn computer science, functional programming is a programming paradigm — a style of building the structure and elements of computer programs— that treats computation as the **evaluation of mathematical functions and avoids changing-state and mutable data**.\n\nIt is a **declarative** programming paradigm, which means programming is done with expressions or declarations instead of statements. To put it in a diferent way we can say that\n**declarative programming cares about what** to perform an action and imperative cares about how to perform that action\n\n## Declarative Vs. Imperative || What Vs. How\n\nIn functional code, the output value of a function depends only on the arguments that are passed to the function, so calling a function f twice with the same value for an argument x produces the same result f(x) each time; this is in contrast to procedures depending on a local or global state, which may produce different results at different times when called with the same arguments but a different program state. Eliminating side effects, i.e., changes in state that do not depend on the function inputs, can make it much easier to understand and predict the behavior of a program, which is one of the key motivations for the development of functional programming.\n\nIn contrast, imperative programming changes state with commands in the source code, the simplest example being assignment. Imperative programming does have functions—not in the mathematical sense—but in the sense of subroutines. They can have side effects that may change the value of program state. Functions without return values therefore make sense. Because of this, they lack referential transparency, i.e., the same language expression can result in different values at different times depending on the state of the executing program.\n\n**IMPERATIVE**\n\n```javascript\nfor (var i = 0; i < users.length; i++) {\n  users[i].lastModified = new Date();\n}\n```\n\n**DECLARATIVE**\n\n```javascript\nusers.mnap((u) => {\n  u.lastModified = new Date();\n  return u;\n});\n```\n\n## Mathematical Functions ( Pure Functions)\n\nFunctions that with the same input always return the same output. They don't deppend in any other data other than what is passed to the funtion and don't alter dataother than what they returned\n\n## Mutable data\n\nMutable data is data that can be change.\nAn example will be to order an array. If we have an unorder array and we create a function that shorts that array if the function return a new array with the shorting this will be unmutable data because we did not change the original array, but if the function takes our initial array and modify it then the data is mutable and we will loose the original reference of the array and we can have side effects\n\n## Working with array Functions\n\n```javascript\n// Returns the value of the first element in an array that pass a test\nusers.find((u) => {\n  return u.id === id;\n});\n// Checks if every element in an array pass a test\nusers.every((u) => {\n  return u.isAdmin;\n});\n// Checks if any of the elements in an array pass a test\nusers.some((u) => {\n  return u.isAdmin;\n});\n// Creates a new array with every element in an array that pass a test\nusers.filter((u) => {\n  return u.isAdmin;\n});\n// Creates a new array with the result of calling a function for each array element\nusers.map((u) => {\n  u.updated = new Date();\n  return u;\n});\n// Reduce the values of an array to a single value (going left-to-right)\nusers.reduce((accumulator, n) => {\n  return accumulator + n;\n}, 0);\n```\n\n## Chaining\n\nExercise: For a given array of numer we what to:\n\n1.  reduce every value by 1.\n2.  summ all resulting values that are divisible by 3\n\nSolution:\n\n**IMPERATIVE**\n\n```javascript\n// given array\nlet numbers = [2, 4, 10, 12, 19, 23];\nlet sum = 0;\n\nfor (let i = 0; i < numbers.length; i++) {\n  numbers[i] = numbers[i] - 1;\n  if (numbers[i] % 3 == 0) {\n    sum += numbers[i];\n  }\n}\n\nconsole.log(sum); // sum = 30;\n```\n\n**DECLARATIVE**\n\n```javascript\n// given array\n// given array\nlet numbers = [2, 4, 10, 12, 19, 23];\n\nlet substractOne = (n) => n - 1;\nlet isDivisbleBy3 = (n) => (n % 3 === 0 ? n : null);\nlet add = (n, i) => n + i;\n\nlet sum = numbers.map(substractOne).filter(isDivisbleBy3).reduce(add, 0);\n\nconsole.log(sum); // sum = 30;\n```\n\n## Currying\n\nConvert a function that accepts multiple parameters into a series of functions that each only take 1 parameter\n\nLet's see an example: <br>\n\n```javascript\n  // starting from\n  users.find((u) => {\n    return u.id === id;\n  });\n\n// now we could do soomethig like:\n\nconst byId = (item) => {\n  return item.id === id;\n}\n\nusers.find(byId)\n\n// the problem with the above code is that id will be undefined since we need 2 params and we are passing only one\n\n// the solution will be a function that returns another function\nconst byId = (id) => {\n  return (item) => {\n    return item.id === id;\n  }\n}\n\nusers.find(byId(2))\n\n// So this also means that you could use byId in any place and you can call it like:\nbyId(2)(users)\n\n// Ramda has a curry function that does currying\n\nconst byId = R.curry(id, item) {\n  return item.id === id;\n}\n\nusers.find(byId(2))\n\n// also de advantage of using the R.curry funtion is that it accepts more than 2 parameters\n// for example:\n\nconst add = R.curry((a,b,c,) => {\n  return a + b + c;\n})\n\nadd(1)(2)(3);\n\n\n```\n\nThis is another example\n\n```javascript\nconst convertUnits =\n  (toUnit, factor, offset = 0) =>\n  (input) =>\n    ((offset + input) * factor).toFixed(2).concat(toUnit);\n\nconst milesToKm = convertUnits(\"km\", 1.60936, 0);\nconst poundsToKg = convertUnits(\"kg\", 0.4546, 0);\nconst farenheitToCelsius = convertUnits(\"degrees C\", 0.5556, -32);\n\nmilesToKm(10); //\"16.09 km\"\npoundsToKg(2.5); //\"1.14 kg\"\nfarenheitToCelsius(98); //\"36.67 degrees C\"\n\nconst weightsInPounds = [5, 15.4, 9.8, 110];\n\n// without currying\n// const weightsInKg = weightsInPounds.map(x => convertUnits('kg', 0.45460, 0)(x));\n\n// with currying\nconst weightsInKg = weightsInPounds.map(poundsToKg);\n// 2.27kg, 7.00kg, 4.46kg, 50.01kg\n```\n\n## Partial application\n\nSupplying less arguments than required\n\n<div class=\"bibliography\">\nBibliography:\n\n- Wikipedia: https://en.wikipedia.org/wiki/Functional_programming <br>\n- Pluralsite video: [(Fundamentals of Functional Programming in JavaScript by Nate Taylor)](https://app.pluralsight.com/library/courses/javascript-functional-programming-fundamentals/exercise-files)<br>\n- w3School: [JavaScript Array Reference](https://www.w3schools.com/jsref/jsref_obj_array.asp)\n</div>\n",
    "path": "/blog/functional/functional-programming",
    "id": "3"
  },
  {
    "title": "programming functors",
    "description": "Understanding functors as a design pattern for safely manipulating wrapped values in functional programming",
    "pubDate": "2019-01-01",
    "tags": [
      "declarative",
      "Pure functions",
      "Inmutable",
      "currying"
    ],
    "categories": [
      "functional"
    ],
    "draft": false,
    "heroImage": "/blog-placeholder-15.jpg",
    "content": "\n> **Functor is simply an interface with a contract.**<br>\n> We could have just as easily named it Mappable, but now, where's the fun in that?.<br> > _Professor Frisby's_\n\nA functor is nothing more than a data structure that you can map functions with the purpose of\nlifting values intro a wrapper, modifying them, and then putting them back into a wrapper.\n\nIt is a design pattern that defines semantics for how **fmap** should work\n\n` fmap :: (A -> B) -> Wrapper(A) -> Wrapper(B)`\n\nLet's see an example:\n\n```javascript\n// NOTE: we can't use arrow function if we are referencing this inside the function (no \"new\" for arrow functions)\nvar Container = function (x) {\n  this.__value = x;\n};\n\nContainer.of = function (x) {\n  return new Container(x);\n};\n\nContainer.of(3); // => Contaier(3) === { \"__value\": 3 }\nContainer.of(Container.of(\"pepinillos\")); // => Container(Container(\"pepinillos\")) === { \"__value\": { \"__value\": \"pepinillos\" } }\n```\n\n- `Container` is an object with one property.\n\n- Lots of containers just hold one thing, though they aren't limited to one.\n  We've arbitrarily named its property `__value`.\n\n- The `__value` cannot be one specific type or our `container` would hardly live up to the name.\n\n- Once data goes into the `Container` it stays there. We could get it out by using `.__value` , but that would defeat the purpose.\n\n---\n\nSo now let's recap again about the idea of a functor. What is a functor and what a functor should have.\n\nA functor will be mainly a container, and why do we want to do that?, well containerizing (or wrapping) values is a fundamental design pattern in functional programming\nbecause it **guards direct access to the values** so they can be manipulated safely and immutably in your programs.\n\n```javascript\nclass Wrapper {\n  constructor(value) {\n    this._value = value;\n  }\n\n  toString() {\n    return \"Wrapper (\" + this._value + \")\";\n  }\n}\n\n// wrap :: A -> Wrapper(A)\nconst wrap = (val) => new Wrapper(val);\nwrap(\"Hello Muzzy\").toString(); // -> Wrapper (Hellow Muzzy)\n```\n\nNow that we have a container for our values we need something to operate those values , because accessing a wrapped value can only be done by **mapping an operation to its container**.\n\nSo a functor must be a wrapped object and a function to **map** over the values, in functional world they use to call this function **map** or **fmap**\n\n```javascript\nclass Wrapper {\n  constructor(value) {\n    this._value = value;\n  }\n  toString() {\n    return \"Wrapper (\" + this._value + \")\";\n  }\n\n  // map :: (A -> B) -> A -> B\n  map(fn) {\n    return fn(this._value);\n  }\n}\n// wrap :: A -> Wrapper(A)\nconst wrap = (val) => new Wrapper(val);\nwrap(\"Hello Muzzy\").toString(); // -> Wrapper (Hellow Muzzy)\nwrap(\"Hello Muzzy\").map((item) => item.toUpperCase()); // --> HELLOW MUZZY\n```\n\nIn the above example we are mapping over the value but the problem is that we are returning the value transformed already , witch is ok but we cannot chain any thing else withing this container\nand we loose the ability to box our data because we exit our \"safe container\".\n\nSo maybe a good idea will be to return the mapped result into a new wrapper instead of returning only the result. So we change our function map into an **fmap**\n\n```javascript\nclass Wrapper {\n  constructor(value) {\n    this._value = value;\n  }\n  toString() {\n    return \"Wrapper (\" + this._value + \")\";\n  }\n\n  // fmap :: (A -> B) -> Wrapper[A] -> Wrapper[B]\n  fmap(fn) {\n    return new Wrapper(fn(this._value));\n  }\n}\n// wrap :: A -> Wrapper(A)\nconst wrap = (val) => new Wrapper(val);\nwrap(\"Hello Muzzy\").toString(); // -> Wrapper (Hellow Muzzy)\nwrap(\"Hello Muzzy\").fmap((item) => item.toUpperCase()); // --> Wrapper { _value: 'HELLO MUZZY' }\n```\n\nSo now we are returning a new Wrapper object with the value transformed after applying the mapped function (toUpperCase).\n\nfmap knows how to apply functions to values wrapped in a context. It first opens the container,\nthen applies the given function to its value, and finally closes the value back into a new container of the **same type**.\n\nThis allows us to chain more actions within our wrapped value.\n\nSo imagine that we want to upper case and then split words into an array, we could easily do:\n\n```javascript\nclass Wrapper {\n  constructor(value) {\n    this._value = value;\n  }\n  toString() {\n    return \"Wrapper (\" + this._value + \")\";\n  }\n\n  // fmap :: (A -> B) -> Wrapper[A] -> Wrapper[B]\n  fmap(fn) {\n    return new Wrapper(fn(this._value));\n  }\n}\n// wrap :: A -> Wrapper(A)\nconst wrap = (val) => new Wrapper(val);\n\nwrap(\"Hello Muzzy\")\n  .fmap((item) => item.toUpperCase())\n  .fmap((item) => item.split(\" \")); // -->  Wrapper { _value: [ 'HELLO', 'MUZZY' ] }\n```\n\nThen after having an fmap function that returns the same type object we can also state that a functor will follow these two rules:\n\n1. **Preserves identity**\n\n```javascript\n    object.fmap(x => x) ≍ object\n```\n\n2. **Composable**\n\n```javascript\n    object.fmap(compose(f, g)) ≍ object.fmap(g).fmap(f)\n```\n\n<br>\n\nAn finally we can say then that an object will be a functor if it fulfills these rules:\n**1) It is a wrapper object to contain our data**<br>\n**2) had a map function to iterate over its own data**<br>\n**3) preserves identity**<br>\n**4) can be composable**<br><br>\n\n<hr>\n<div class=\"bibliography\">\nBibliogrphy:<br><br>\n\n- Functional Programming in JavaScript . Ed: MANNING SHELTER ISLAND. Author: Luis Atencio.\n- [Mostly Adequate Guide to functional programming](https://drboolean.gitbooks.io/mostly-adequate-guide-old/content/).\nProfessor Frisby's<br>\n</div>\n",
    "path": "/blog/functional/functors",
    "id": "4"
  },
  {
    "title": "Memoize",
    "description": "A more function memoizer",
    "pubDate": "2019-11-11",
    "tags": [
      "declarative",
      "Pure functions",
      "Inmutable",
      "currying",
      "functors"
    ],
    "categories": [
      "functional"
    ],
    "draft": true,
    "heroImage": "/blog-placeholder-9.jpg",
    "content": "\n```javascript\n// A more functional memoizer\n\n//We can beef up our module by adding functions later\nvar Memoizer = (function () {\n  //Private data\n  var cache = {};\n  //named functions are awesome!\n  function cacher(func) {\n    return function () {\n      var key = JSON.stringify(arguments);\n      if (cache[key]) {\n        return cache[key];\n      } else {\n        val = func.apply(this, arguments);\n        cache[key] = val;\n        return val;\n      }\n    };\n  }\n  //Public data\n  return {\n    memo: function (func) {\n      return cacher(func);\n    },\n  };\n})();\n\nvar fib = Memoizer.memo(function (n) {\n  if (n < 2) {\n    return 1;\n  } else {\n    return fib(n - 2) + fib(n - 1);\n  }\n});\n```\n",
    "path": "/blog/functional/memoize",
    "id": "5"
  },
  {
    "title": "monads",
    "description": "Exploring monads as specialized functors for handling null data and streamlining error handling in functional programming",
    "pubDate": "2019-11-11",
    "tags": [
      "declarative",
      "Pure functions",
      "Inmutable",
      "currying",
      "functors"
    ],
    "categories": [
      "functional"
    ],
    "draft": true,
    "heroImage": "/blog-placeholder-8.jpg",
    "content": "\nSo let's remember first what's a functor:\n\n    1. It is a wrapper object to contain our data\n    2. had a map function to iterate over its own data\n    3. preserves identity\n    4. can be composable\n\nBut functors by themselves aren't compelling, because they're not expected to\nknow how to handle cases with **null data**.<br> `Ramda's R.compose`, for instance,\nwill break if a null function reference is passed into it. This isn't a flaw\nin the design; it's intentional.\n\n- Functors map functions of one type to another.\n\n- More-specialized behavior can be found in functional data types called monads.\n\n- Among other things, monads can streamline error handling in your code,allowing\n  you to write fluent function compositions.\n\n- What's their relationship to functors? **Monads are the containers\n  that functors \"reach into.\"**\n",
    "path": "/blog/functional/monads",
    "id": "6"
  },
  {
    "title": "transducers",
    "description": "Exploring transducers in functional programming for efficient data transformation pipelines without creating intermediate values",
    "pubDate": "2019-01-01",
    "tags": [
      "declarative",
      "Pure functions",
      "Inmutable",
      "currying",
      "functors",
      "transducers"
    ],
    "categories": [
      "functional"
    ],
    "draft": true,
    "heroImage": "/blog-placeholder-16.jpg",
    "content": "\nThe primary goal of transducers is to run a pipeline of transformations of an input stream of\nvalues **without creating intermediate values**. The functions describing computations are\ndecoupled, so this makes program design cleaner and easier to develop and maintain.\n\nA transducer is a function that accepts a transformer and returns a transformer and can be composed directly\n\nTransducers can:\n\n- Be Composable\n- They only enumerates over the elements **onces** (very efficient for working with data streams)\n- can be use for lazy or eager evaluation\n- You can combine transducer to generate another transducer (High order reducers ¿?)\n\nThere are two strategies:\n\n- **Pull:** lazy evaluation\n- **Push:** eager evaluation\n\n**Pull** waits until a consumer asks for the next value (for example an Iterable)\n\n**Push** enumerates over the source values and pushes them through the tubes ASAP (Array.reduce())\n\nTransducers compose top to bottom (left to right)\n\n**Example:**\n\nGiven an array of autobots we want to:\n\n1. ﬁlter out values that don't contain the letter 'r',\n2. uppercase\n3. reverse each value\n\n**First approach without a tranducer**\n\n```javascript\nconst R = require(\"ramda\"); // Ramda functional library\n\nlet autobots = [\n  \"Optimus Prime\",\n  \"Bumblebee\",\n  \"Ironhide\",\n  \"Sunstreaker\",\n  \"Ratchet\",\n];\n\n// Filter for autobots that contain 'r', uppercase, then reverse\nlet transform = R.compose(\n  R.filter((x) => /r/i.test(x)),\n  R.map(R.toUpper),\n  R.map(R.reverse)\n);\n\ntransform(autobots);\n// => [ 'EMIRP SUMITPO', 'EDIHNORI', 'REKAERTSNUS', 'TEHCTAR' ]\n```\n\n**Same approach with tranducer**\n\n```javascript\nconst R = require(\"ramda\"); // Ramda functional library\n\nlet autobots = [\n  \"Optimus Prime\",\n  \"Bumblebee\",\n  \"Ironhide\",\n  \"Sunstreaker\",\n  \"Ratchet\",\n];\n\n// Filter for autobots that contain 'r', uppercase, then reverse\nlet transform = R.compose(\n  R.filter((x) => /r/i.test(x)),\n  R.map(R.toUpper),\n  R.map(R.reverse)\n);\n\ntransform(autobots);\n// => [ 'EMIRP SUMITPO', 'EDIHNORI', 'REKAERTSNUS', 'TEHCTAR' ]\n```\n\nWe get the same exact result (in this situation), but something very different and very powerful\nis happening under the hood. **In the first example, the entire list was transformed at each step**.<br>\nThis means that we had to iterate over the list three times. However, **in the second example**\nwhere we used the transducer, **we only had to iterate over the list once!**\n\n<div class=\"bibliography\">\nBibliogrphy:<br><br>\n\n- [effectfulJS](https://github.com/awto/effectfuljs/tree/master/packages/transducers)\n- [Understanding Transducers in JavaScript](https://medium.com/@roman01la/understanding-transducers-in-javascript-3500d3bd9624)\n- [MAGICAL, MYSTICAL JAVASCRIPT TRANSDUCERS](https://jrsinclair.com/articles/2019/magical-mystical-js-transducers/)\n- [Transducers: Efficient Data Processing Pipelines in JavaScript](https://medium.com/javascript-scene/transducers-efficient-data-processing-pipelines-in-javascript-7985330fe73d).\n</div>\n",
    "path": "/blog/functional/transducers",
    "id": "7"
  },
  {
    "title": "Global variables are bad",
    "description": "Exploring the dangers of global variables in JavaScript, including scope pollution, concurrency issues, and best practices for variable declaration",
    "pubDate": "2018-06-14",
    "tags": [
      "javascript",
      "globals"
    ],
    "categories": [
      "javascript"
    ],
    "draft": false,
    "heroImage": "/blog-placeholder-14.jpg",
    "content": "\n## Extracted from a Gist, a very nice explanation\n\n```javascript\n\n// It is important to declare your variables.\n\n(function() {\n    var foo = 'Hello, world!';\n    print(foo);  //=> Hello, world!\n})();\nprint(foo);  // No way José !!\n\n// Because if you don't, the become global variables.\n\n(function() {\n    foo = 'Hello, world!';\n    print(foo)  //=> Hello, world!\n})();\n\nprint(foo)  //=> WTF, it returns \"Hello, world!\"\n\n\n// When global variables sneak into your code they can cause problems.\n// Especially in applications with concurrency.\n\nvar count = function() {\n    for (i = 0; i < 10; i += 1) {\n        print(i);\n    }\n};\n\ncount();  //=> 0 1 2 3 4 5 6 7 8 9\n\nvar countSilently = function() {\n    for (i = 0; i < 10; i += 1) {\n        // don't print anything;\n    }\n};\n\n// Both loops increment i at the same time, which causes strange behavior.\nwindow.setTimeout(countSilently, 10);\nwindow.setTimeout(count,         10);  //=> 2 3 7 8 9\n\n\n// You can use 'this' in method definitions to refer to attributes of the\n// method's object.\n\nvar obj = {\n    name: 'foo',\n    introduce: function() {\n        print(this.name);\n    }\n};\n\nobj.introduce();  //=> foo\n\n// But 'this' does not follow the normal rules of scope in JavaScript. One\n// might expect 'this' to be available with the same value via closure in the\n// callback defined inside the method here.\n\nvar obj = {\n    name: 'foo',\n    introduce: function() {\n        window.setTimeout(function() {\n            print(this.name);\n        }, 3000);\n    }\n};\n\nobj.introduce(); //=> *pause* undefined\n\n// In fact, this got bound to the global object in the callback. To get around\n// this, assign the object reference to a regular variable that will have the\n// same value inside the callback definition.\n\nvar obj = {\n    name: 'foo',\n    introduce: function() {\n        var that = this;\n        window.setTimeout(function() {\n            print(that.name);\n        }, 3000);\n    }\n};\n\nobj.introduce();  //=> *pause* foo\n\n\n// The keyword 'this' is actually dynamically assigned whenever a function is\n// invoked. When a function is invoked as a method, i.e. obj.method(), 'this'\n// is bound to 'obj'. But when a function is invoked by itself 'this' is bound\n// to the global object.\n\nvar phrase = 'Hello, world!';\nvar printPhrase() {\n    print(this.phrase);\n}\n\nprintPhrase();  //=> Hello, world!\n\n// This is true even of functions that were defined as a method.\n\nvar obj = {\n    name: 'foo',\n    introduce: function() {\n        print(this.name);\n    }\n};\n\n// When the function is invoked without 'obj.' in front of it, 'this' becomes\n// the global namespace.\n\nvar introduce = obj.introduce;\nintroduce();  //=> undefined\n\n\n// Method invocation and function invocation are two of the invocation patterns\n// in JavaScript. A third is apply invocation, which gives us control over what\n// 'this' will be assigned to during function execution.\n\nintroduce.apply(obj, null);  //=> foo\n\n// 'apply' is a method on Function. The first argument is the value that 'this'\n// will be bound to. Successive arguments to apply are passed as arguments to\n// the function that is being invoked.\n\nvar chatty = function(repeatTimes) {\n    var i;\n    for (i = 0; i < repeatTimes; i += 1) {\n        print(this.name + ' ');\n    }\n}\nchatty.apply(obj, 3)  //=> foo foo foo\n\n\n// The fourth and final invocation pattern in JavaScript is constructor\n// invocation. This pattern was designed to provide a way to create new objects\n// that would appear familiar to programmers who are used to programming with\n// classes.\n\nvar Cat = function(name) {\n    this.name = name;\n};\nCat.prototype = {\n    query: function() {\n        print(this.name + ' says, \"meow\"');\n    }\n};\n\n// When a function is called with the 'new' keyword in front of it, a new\n// object is created and is bound to 'this' when the function runs. Special\n// constructor functions use this feature to customize new objects as they are\n// created.\n\nvar whiskers = new Cat('whiskers');\nwhiskers.query();  //=> whiskers says \"meow\"\n\n// When a new object is created with 'new', the prototype of the new object is\n// set to the prototype of the constructor function. So the new object inherits\n// all of the attributes of the constructor's prototype value. In this case,\n// new cat objects inherit the 'query' method from Cat.prototype.\n\nvar nibbler = new Cat('nibbler');\nnibbler.query();  //=> nibbler says \"meow\"\n\n\n// If a constructor function is called without the 'new' keyword, it is invoked\n// with the ordinary function invocation pattern.\n\nvar gotcha = Cat('gotcha!');\ngotcha.query();  //=> typein:165: TypeError: gotcha has no properties\n\n// So 'this' is assigned to the global object instead of to a newly created object. That means that any attributes assigned to the new object by the constructor function become global variables!\n\nprint(name);  //=> gotcha!\n\n\n// Constructor invocation is pretty complicated and prone to disastrous global\n// variable creation. Here is a cleaner way to create new objects that inherit\n// from other objects.\n\n// This defines Object.create, a method that simplifies the behavior of the\n// 'new' keyword. This method was invented by Douglas Crockford.\n// http://javascript.crockford.com/prototypal.html\nif (typeof Object.create !== 'function') {\n    Object.create = function(o) {\n        var F = function() {};\n        F.prototype = o;\n        return new F();\n    };\n}\n\n// Object.create(obj) returns a new object that inherits all of the attributes\n// of obj. The 'cat' prototype object here defines a 'clone' method that wraps\n// around Object.create to customize new 'cat' objects as they are created.\n\nvar cat = {\n    query: function() {\n        print(this.name + ' says \"meow\"');\n    },\n    clone: function(name) {\n        var newCat = Object.create(this);\n        newCat.name = name;\n        return newCat;\n    }\n};\n\nvar fluffy = cat.clone('fluffy');\nfluffy.query();  //=> fluffy says \"meow\"\n\n// In addition to inheriting 'query', new cats also inherit 'clone'.\n\nvar fluffy2 = fluffy.clone('fluffy2');\nfluffy2.query();  //=> fluffy2 says \"meow\"\n\n// Methods and attributes are inherited, not copied. If you change the\n// definition of 'clone' on 'cat' at this point, the change will be reflected\n// in cat objects that have already been created.\n\nfluffy2.hasOwnProperty('clone')  //=> false\nfluffy.hasOwnProperty('clone')  //=> false\ncat.hasOwnProperty('clone')  //=> true\n\n```\n\n<br>\nBibliography:<br>\nhttps://gist.github.com/hallettj/64478\n",
    "path": "/blog/global-variables-are-bad",
    "id": "8"
  },
  {
    "title": "Lexical and Dynamic scope",
    "description": "Understanding lexical and dynamic scoping in JavaScript, including the eval keyword and its performance implications",
    "pubDate": "2018-01-14",
    "tags": [
      "scope",
      "eval",
      "javascript"
    ],
    "categories": [
      "javascript"
    ],
    "draft": false,
    "heroImage": "/blog-placeholder-18.jpg",
    "content": "\n# Lexical scoping\n\n## Evil eval\n\nWe can cheat on lexical scoping using eval keywod. <br>\nThe eval keyword, takes any given strings and it treats as it was a code\n\n```javascript\nvar bar = \"foo\";\nfunction foo(str) {\n  eval(str);\n  console.log(\"bar\"); // 42 !!!!!\n}\n\nfoo(\"var bar = 42\");\n```\n\nThe problem of doing this is that performance will be afected because as we know JS first assign the LHS (left hand side), witch means that it will read all the assigments on the left and lator will do the right hand side of the code. In the case of the eval function we are using a RHS that contains a LHS and RHS statement and that means that JS compiler will not be able to do a code optimization because the engine cannot assume the lexical scoping to be unchange. So even if we declare an eval and not using it to do a declaration it will have a side effect on perfomance in our code.<br>\nSo to summarize in general we should not use eval key\n\n## with with\n\nWe can also skeep lexical scope by doing even a worse thing and that is using the with statement\n\n## A note about LHS and RHS\n\nLHS look-up is done when a variable appears on the left-hand side of an assignment operation, and an RHS look-up is done when a variable appears on the right-hand side of an assignment operation.\n\nI think of it as follows :<br>\nlhs lookup is a container lookup <br>\nrhs lookup is a value lookup<br>\n\n# Dynamic scope\n\n### Bibliograpy:<br>\n\nhttps://stackoverflow.com/questions/36383795/javascript-lhs-and-rhs-lookup\nPlural sight course: Advanced javascript, by kyle Simpson\n",
    "path": "/blog/lexical-and-dynamic-scope",
    "id": "9"
  },
  {
    "title": "Method chaining in javascript",
    "description": "Understanding method chaining in JavaScript for creating fluent interfaces and improving code readability through sequential method calls",
    "pubDate": "2018-01-08",
    "tags": [
      "javascript",
      "method chaining"
    ],
    "categories": [
      "javascript"
    ],
    "draft": false,
    "heroImage": "/blog-placeholder-20.jpg",
    "content": "\n# Method chaining in Javascript\n\nfrom [wikipedia](https://en.wikipedia.org/wiki/Method_chaining) <br>\nMethod chaining, also known as named parameter idiom, is a common syntax for invoking multiple method calls in object-oriented programming languages.\n\nThe key to achieve this is that each method returns an object, allowing the calls to be chained together in a single statement without requiring variables to store the intermediate results.\n\nA similar syntax is method cascading, where after the method call the expression evaluates to the current object, not the return value of the method. Cascading can be implemented using method chaining by having the method return the current object itself. Cascading is a key technique in fluent interfaces, and since chaining is widely implemented in object-oriented languages while cascading isn't, this form of \"cascading-by-chaining by returning this\" is often referred to simply as \"chaining\". Both chaining and cascading come from the Smalltalk language.\n\nWhile chaining is syntax, it has semantic consequences, namely that requires methods to return an object, and if implementing cascading via chaining, this must be the current object. This prevents the return value from being used for some other purpose, such as returning an error value.\n\nTo see an example lest first define our use case:\n\nImagine that we have a class person that has some methods (or functions), these are:\n\n```javascript\nsetName();\nsetEyeColor();\nsetHairColor();\nsetHeight();\n```\n\nAnd this is the definition of our class\n\n```javascript\n// Definition of the class\n// ------------------------\nclass Person {\n  constructor() {\n    console.log(\"person created\");\n  }\n\n  setName(name) {\n    this.name = name;\n  }\n\n  setEyeColor(eyeColor) {\n    this.eyeColor = eyeColor;\n  }\n\n  setHairColor(hairColor) {\n    this.HairColor = hairColor;\n  }\n\n  setHeight(height) {\n    this.height = height;\n  }\n}\n```\n\nNow if we want to create a person and execute all methods we will do :\n\n```javascript\n// Execution\n// ---------\n\nvar pers = new Person();\npers.setName(\"Joe\");\npers.setEyeColor(\"blue\");\npers.setHairColor(\"black\");\npers.setHeight(\"1.75\");\n\nconsole.log(pers);\n```\n\nSo far so good.\n\nBut this could be improved doing method chaining. This way we will remove the call of pers object every time we want to execute a function of that object.\n<br/ >So our execution will be something like this:\n\n```javascript\nvar pers = new Person()\n  .setName(\"Joe\")\n  .setEyeColor(\"blue\")\n  .setHairColor(\"black\")\n  .setHeight(\"1.75\");\nconsole.log(pers);\n```\n\nOr better yet, we can apply some formating and also we don't even need to assign a var to person since we are doing method chaining , rewriting the above syntax as:\n\n```javascript\nconsole.log(\n  new Person()\n    .setName(\"Joe\")\n    .setEyeColor(\"blue\")\n    .setHairColor(\"black\")\n    .setHeight(\"1.75\")\n);\n```\n\nThe problem comes now because if we execute the above sentence we will end up with a compiler error.\nThis is because when we create a new person, none of the methods that we previously define are returning a value, so after the first method call the compiler does not know in what object to execute the next function.\n\nTo solve this we will need to redefine our methods to return the same object, like this\n\n```javascript\nclass Person {\n  constructor() {\n    console.log(\"person created\");\n  }\n\n  setName(name) {\n    this.name = name;\n    return this;\n  }\n\n  setEyeColor(eyeColor) {\n    this.eyeColor = eyeColor;\n    return this;\n  }\n\n  setHairColor(hairColor) {\n    this.HairColor = hairColor;\n    return this;\n  }\n\n  setHeight(height) {\n    this.height = height;\n    return this;\n  }\n}\n```\n\nAnd now we can do method chaining.\n\n```javascript\nconsole.log(\n  new Person()\n    .setName(\"Dina\")\n    .setEyeColor(\"black\")\n    .setHairColor(\"brown\")\n    .setHeight(\"1.85\")\n);\n\n// Person {HairColor:\"brown\", eyeColor:\"black\", height:\"1.85\", name:\"Dina\"}\n```\n",
    "path": "/blog/method-chaining-in-javascript",
    "id": "10"
  },
  {
    "title": "Object attribute properties",
    "description": "Exploring JavaScript object property attributes including value, configurable, enumerable, and writable flags",
    "pubDate": "2018-01-12",
    "tags": [
      "javascript",
      "object properties"
    ],
    "categories": [
      "javascript"
    ],
    "draft": false,
    "heroImage": "/blog-placeholder-19.jpg",
    "content": "\nAtributos de las propiedades\nCada una de las propiedades tiene 4 atributos, los cuales son\n\nvalue\nconfigurable\nenumerable\nwritable\n\nBibliography <br>\n[Yeison Daza](https://medium.com/entendiendo-javascript/entendiendo-los-objetos-en-javascript-3a6d3a0695e5)\n",
    "path": "/blog/object-atribute-properties",
    "id": "11"
  },
  {
    "title": "IIFE",
    "description": "Understanding Immediately Invoked Function Expressions (IIFE) in JavaScript and their use in preventing global scope pollution",
    "pubDate": "2018-01-14",
    "tags": [
      "design patterns",
      "IIFE"
    ],
    "categories": [
      "design patterns"
    ],
    "draft": false,
    "heroImage": "/blog-placeholder-6.jpg",
    "content": "\n# IIFE - Iimmediatelly Invoked Function Expression\n\n```javascript\nvar foo = \"foo1\";\n\n(function () {\n  var foo = \"foo2\";\n  console.log(foo); // foo2\n})();\n\nconsole.log(foo); // foo1\n\n// we can also write the above statement like:\n(function () {\n  // code\n})();\n```\n\nWe use IIFE in order to not pollute the global scope.\n\n<div class=\"bibliography\">\nBibliography: <br/><br/>\n\n- Ben Alman: [Immediately-Invoked Function Expression (IIFE)](http://benalman.com/news/2010/11/immediately-invoked-function-expression/)\n\n</div>\n",
    "path": "/blog/patterns/iife",
    "id": "12"
  },
  {
    "title": "Mixins",
    "description": "Understanding mixins in JavaScript as a solution for multi-inheritance, including delegation, concatenative, and functional inheritance patterns",
    "pubDate": "2018-11-18",
    "tags": [
      "design patterns",
      "mixins",
      "functional mixins",
      "inherence"
    ],
    "categories": [
      "design patterns"
    ],
    "draft": false,
    "heroImage": "/blog-placeholder-7.jpg",
    "content": "\nIn JavaScript we can only inherit from a single object. There can be only one **[[Prototype]]** for\nan object.\nAnd a class may extend only one other class.\n\n**To solve the use of multi inheritance we use mixins**.\n\nIn object-oriented programming languages, a Mixin is a class that contains methods for use by\nother classes without having to be the parent class of those other classes.\n\nA mixin can also be viewed as an **interface with implemented methods**.\nThis pattern is an example of enforcing the [**dependency inversion principle**](https://en.wikipedia.org/wiki/Dependency_inversion_principle).\n\n## Inheriting \"methods\"\n\nJavaScript does not have methods in the form that class-based languages define them.\n**In JavaScript, any function can be added to an object in the form of a property**.\nAn inherited function acts just as any other property, including property shadowing\n\nThere is more than one type of prototypal inheritance:\n\n- **Delegation** (i.e., the prototype chain).\n- **Concatenative** (i.e. mixins, `Object.assign()`).\n- **Functional** (Not to be confused with functional programming. A function used to create a\n  closure for private state/encapsulation).\n\nEach type of prototypal inheritance has its own set of use-cases, but all of them are equally\nuseful in their ability to enable composition, which creates **has-a** or **uses-a** or **can-do**\nrelationships as opposed to the is-a relationship created with class inheritance.\n\n## Delegation\n\nWe can work with delegation by using apply, bind or call to inherit from another object. Let's\nsee an example: <br>\n\n```javascript\nfunction Product(name, price) {\n  this.name = name;\n  this.price = price;\n}\n\nfunction Food(name, price) {\n  Product.call(this, name, price);\n  this.category = \"food\";\n}\n\nfunction Toy(name, price) {\n  Product.call(this, name, price);\n  this.category = \"toy\";\n}\n\nvar cheese = new Food(\"feta\", 5);\nvar fun = new Toy(\"robot\", 40);\n```\n\n<a href=\"../testing-protoype-inheritance/\" target=\"_self\">This is another \"tricky\"\nexample </a>\n\n## Concatenative\n\n**Using Object.assign() as mixin**\n\n```javascript\n// mixin\nlet sayHiMixin = {\n  sayHi() {\n    alert(`Hello ${this.name}`);\n  },\n  sayBye() {\n    alert(`Bye ${this.name}`);\n  },\n};\n\n// usage:\nconst User = function (name) {\n  this.name = name;\n};\n\n// copy the methods\nObject.assign(User.prototype, sayHiMixin);\n// now User can say hi\nnew User(\"Dude\").sayHi(); // Hello Dude!\n```\n\n**or if you were using classes you could do something like this:**\n\n```javascript\nclass User extends Person {\n  // ...\n}\n\nObject.assign(User.prototype, sayHiMixin);\n```\n\n###Functional Mixins\n\nIf the functions defined by mixins are intended solely for the use of other objects,\nwhy bother creating mixins as regular objects at all? Put another way, a **mixin should be a\nprocess not an object**.\n\nThe logical conclusion is to make our mixins into functions into which consumer objects inject\nthemselves by delegation, thus cutting out the middle guy (the extend function) entirely.\n\n```javascript\nvar asCircle = function () {\n  this.area = function () {\n    return Math.PI * this.radius * this.radius;\n  };\n  this.grow = function () {\n    this.radius++;\n  };\n  this.shrink = function () {\n    this.radius--;\n  };\n  return this;\n};\n\nvar Circle = function (radius) {\n  this.radius = radius;\n};\n\nasCircle.call(Circle.prototype);\n\nvar circle1 = new Circle(5);\ncircle1.area(); //78.54\n```\n\n**Mixins as verbs instead of nouns**\n\n### Adding Options\n\nThis functional strategy also allows the borrowed behaviours to be parameterized by means of\nan options argument.\n\n```javascript\nvar asOval = function ({ growBy, shrinkBy }) {\n  this.area = function () {\n    /* ... */\n  };\n  this.ratio = function () {\n    /* ...*/\n  };\n  this.grow = function () {\n    this.shortRadius += growBy / this.ratio();\n    this.longRadius += growBy;\n  };\n  // ...\n  return this;\n};\n\nvar OvalButton = function (/*...*/) {\n  //...\n};\n// ...\nasOval.call(OvalButton.prototype, { growBy: 2, shrinkBy: 2 });\n```\n\n**Further reading [Traits](https://github.com/traitsjs/traits.js)**\n\nBibliography: <br>\n[Angus Croll](https://javascriptweblog.wordpress.com/2011/05/31/a-fresh-look-at-javascript-mixins/?blogsub=confirming%23subscribe-blog]) <br/>\n[javascript.info](https://javascript.info/mixins)<br/>\n[Wikipedia](https://en.wikipedia.org/wiki/Mixin)<br/>\n[Eric Elliott](https://medium.com/javascript-scene/10-interview-questions-every-javascript-developer-should-know-6fa6bdf5ad95)<br/>\n[developer.mozilla](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain)<br/>\n",
    "path": "/blog/patterns/mixins",
    "id": "13"
  },
  {
    "title": "testing prototype inheritance",
    "description": "Exploring prototype inheritance in JavaScript using the call method to inherit properties and methods between objects and functions",
    "pubDate": "2018-11-21",
    "tags": [
      "design patterns",
      "prototype",
      "inheritance"
    ],
    "categories": [
      "design patterns"
    ],
    "draft": false,
    "heroImage": "/blog-placeholder-17.jpg",
    "content": "\nhttps://stackoverflow.com/questions/53406070/using-call-to-inherit-objects-from-a-function\n\n```js\n// testing Call to inherit objects / functions\n// -------------------------------------------\n\n// we declare our first function\nconst funcA = function (firstName) {\n  this.firstName = firstName;\n  this.getFirstName = function () {\n    return \"My name is \" + this.firstName;\n  };\n  return this;\n};\n// Create an object out of that function\nconst objA = new funcA(\"Rodrigo\");\n\n// declare second function\nconst funcB = function (lastName) {\n  this.lastName = lastName;\n  this.getLastName = function () {\n    return \"My last name is \" + this.lastName;\n  };\n  return this;\n};\n\n// Create an Object from funcB and ObjectA\nconst objC = funcB.call(objA, \"Erades\");\n// We get an object\nconsole.log(\"TYPE OF: \", typeof objC);\nconsole.log(\"raw:\", objC);\nconsole.log(\"method A: \", objC.getFirstName());\nconsole.log(\"prop A: \", objC.firstName);\nconsole.log(\"method B: \", objC.getLastName());\nconsole.log(\"prop B: \", objC.lastName);\nconsole.log(\"------------\");\n\n// if we don't want to create an object out of a function and an object,\n// we could also inherit two functions, but the result really surprise me\nconst funcC = funcB.call(funcA, \"Alonso\");\n// We get a function !!!!!\nconsole.log(\"TYPE OF: \", typeof funcC);\nconsole.log(\"raw:\", funcC);\n// To get result we need to do this:\nconsole.log(\"method ==>: \", funcC(\"Rui\"));\nconsole.log(\"method A: \", funcC(\"Rui\").getFirstName());\nconsole.log(\"prop A: \", funcC(\"Maria\").firstName);\nconsole.log(\"method B: \", funcC.getLastName());\nconsole.log(\"prop B: \", funcC.lastName);\nconsole.log(\"------------\");\n```\n",
    "path": "/blog/patterns/testing-protoype-inheritance",
    "id": "14"
  },
  {
    "title": "statement branching Vs micro-branching",
    "description": "Comparing traditional statement branching with micro-branching techniques in JavaScript for more maintainable and functional code",
    "pubDate": "2018-06-06",
    "tags": [
      "statement brnaching",
      "micro-branching strategies"
    ],
    "categories": [
      "javascript",
      "functional"
    ],
    "draft": false,
    "heroImage": "/blog-placeholder-21.jpg",
    "content": "\n## statement branching\n\nAny construct that alters the sequence of statement execution within the global or functional scope. <br>\nThese include:<br>\n\n```\nif\nelse\nswitch\nfor\nwhile\n```\n\nStatements are designed to execute non-linearly. Aside from the obvious bloating effect, statement branching tends to become unintuitive as it progresses.\n\n## micro-branching\n\nConditional logic contained within a statement that has no effect on the statement execution seqeunce.<br>\nThe following operators facilitate micro-branching: <br>\n\n```\nternary (<cond> ? a : b)\n&&\n||\n```\n\nThe logic flows sequentially from top to bottom and even from left to right. There are no forks in the road. There is only one return statement and its at the bottom where we expect it. Best of all it's short. Nothing is wasted. In fact it's terse enough to be barely procedural at all.\n\nAlternatives to statement branching fall into two broad categories: **micro-branching** and **no branching at all**\n\n## Micro-branching strategies\n\n### Guards (&&) and Defaults(||)\n\n```javascript\n//invoke callback if there is one\ncallback && callback();\n//delay by argument or 20\ndelayBy(delay || 20);\n//remove node from its parent\nnode && node.parent && node.parent.removeChild(node);\n//log a test in the console id we have one\nwindow.console && console.log(\"test\");\n```\n\n<br>\n\n<blockquote> Some things just have a natural place. Birds in the sky, fish in the sea and a return statement at the end of a function.</blockquote>\n\n<br>\n\nBibliography:<br>\nhttps://javascriptweblog.wordpress.com/2010/07/26/no-more-ifs-alternatives-to-statement-branching-in-javascript/\n",
    "path": "/blog/statement-branching-vs-micro-branching",
    "id": "15"
  }
]