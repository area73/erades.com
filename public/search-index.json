[
  {
    "title": "Methodologies: How to ask the AI",
    "description": "Practical guide for writing effective prompts using the ASPECCT methodology, with template, real example and comparison with alternative frameworks.",
    "pubDate": "2025-08-10T00:00:00.000Z",
    "tags": [
      "ASPECCT",
      "prompt-engineering",
      "best-practices",
      "artificial-intelligence"
    ],
    "categories": [
      "AI",
      "Crafting"
    ],
    "draft": false,
    "heroImage": "/blog-placeholder-21.jpg",
    "content": "\nThe quality of a model's responses depends largely on the quality of the prompt. **ASPECCT** is a simple and powerful way to structure what you ask for to achieve consistent results.\n\n## What is ASPECCT\n\n- **A — Audience**: defines who the output is for.\n- **S — Style**: tone and register (technical, mentor, formal…).\n- **P — Purpose**: clear goal of the task.\n- **E — Examples**: reference inputs/outputs.\n- **C — Constraints**: word limits, format, prohibitions.\n- **Cxt — Context**: what the model should know about the domain/situation.\n- **T — Type of Output**: expected format (list, table, JSON, Markdown).\n\n## One to give an example\n\nFinal Prompt:\n\n> \"Write a short list (T) that explains the benefits of serverless (P) to startup CTOs (A) using a concise and technical tone (S). It should be less than 80 words and use bullets (C). Context: we are preparing internal documentation for developers inexperienced with AWS (Cxt).\"\n\n## Is the ASPECCT methodology good?\n\nASPECCT encapsulates prompting principles widely recommended by the industry: **provide clear and specific instructions, provide context, show examples, and set an output format**.\n\nThese practices are aligned with the official guides of the companies that generate models:\n\n- **OpenAI:** prompting guides and best practices (clear instructions, break down tasks, provide examples, and output format).\n- **Anthropic:** prompting strategies (role/persona, constraints, context, format, and step-by-step reasoning when appropriate).\n- **Google (Gemini):** prompt design with objectives, context, examples, and response format.\n\nThere is independent evidence that a single framework outperforms others in all cases; **ASPECCT is robust** because it covers the elements that most influence the quality of the response and is easy to apply consistently.\n\n## Other alternatives\n\nAs in everything, and especially when we are at the beginning of this new age, there are other very valid alternatives.\n\n- **CO-STAR** (Context, Objective, Style, Tone, Audience, Response): functionally equivalent to ASPECCT with explicit emphasis on tone and response style. Useful when **branding/voice** is crucial.\n\n- **CRISPE**: popular variants focus on constraints, role/persona, user inputs, steps, and examples. Useful for **repeatable operational tasks with strict checklist**.\n\n- **Best practice from provider** (OpenAI, Anthropic, Google): they combine the same principles with tactical recommendations (e.g., breaking down problems, using examples, asking for a structured format).\n\n- In reasoning problems, it is recommended to add techniques such as \"step-by-step reasoning\" or \"decomposition into subtasks\".\n\n- In structured outputs, specify the schema and validation (e.g., strictly typed JSON).\n\n## An approach to creating the prompt\n\n1. Complete the ASPECCT checklist before writing the prompt.\n2. Write a first draft.\n3. Ask for the result in the exact format (Type of Output) and within boundaries (Constraints).\n4. Iterate with 1–2 examples (Examples) if the output does not comply.\n5. Reinforce purpose, audience, and style if you notice drift.\n\n<div class=\"bibliography\">\n\n## Bibliography and references\n\n- OpenAI — Best practices for prompt engineering: [platform.openai.com/docs/guides/prompt-engineering](https://platform.openai.com/docs/guides/prompt-engineering)\n- Anthropic — Prompt engineering overview (Claude): [docs.anthropic.com/.../prompt-engineering/overview](https://docs.anthropic.com/en/docs/build-with-claude/prompt-engineering/overview)\n- Google — Writing effective prompts (Workspace/Gemini): [workspace.google.com/resources/ai/writing-effective-prompts](https://workspace.google.com/resources/ai/writing-effective-prompts)\n- Microsoft Learn — Prompt engineering (Azure OpenAI): [learn.microsoft.com/.../prompt-engineering](https://learn.microsoft.com/azure/ai-services/openai/concepts/prompt-engineering)\n- Prompt Engineering Guide (DAIR.AI): [promptingguide.ai](https://www.promptingguide.ai/)\n- CO-STAR Framework (introduction and practical examples): [writesonic.com/blog/costar-framework](https://writesonic.com/blog/costar-framework)\n\n</div>\n",
    "path": "/en/blog/ai-take-aways/aspecct-metodologia-prompting",
    "id": "en/ai-take-aways/aspecct-metodologia-prompting"
  },
  {
    "title": "Lessons learned about i18n with AI",
    "description": "Reflections and learnings about internationalization (i18n) using Artificial Intelligence, common challenges and best practices for future development teams.",
    "pubDate": "2024-06-15T00:00:00.000Z",
    "tags": [
      "i18n",
      "internationalization",
      "best-practices",
      "artificial-intelligence",
      "web-development"
    ],
    "categories": [
      "AI",
      "Crafting"
    ],
    "draft": false,
    "heroImage": "/blog-placeholder-24.jpg",
    "content": "\nInternationalization (i18n) has traditionally been one of the most tedious and error-prone processes in web development. However, with the arrival of Artificial Intelligence, we are witnessing a paradigm shift that is completely transforming how we approach translations in our projects.\n\n## The shift in approach: from incremental translation to contextual translation\n\n### The traditional method\n\nTraditionally, the workflow for internationalization followed an incremental pattern:\n\n1. **Parallel development**: We built pages while creating translations simultaneously\n2. **Context fragmentation**: Each text was translated in isolation, losing visual and functional context\n3. **Inconsistencies**: Translations were done in parts, generating inconsistencies in tone and style\n4. **Constant revision**: We needed to review and adjust translations as the interface evolved\n\nThis approach had a fundamental problem: **context loss**. By translating texts in isolation, we lost the complete vision of how the page worked as a whole.\n\n### The new AI paradigm\n\nWith Artificial Intelligence, we can adopt a completely different approach:\n\n1. **Complete monolingual development**: We build the complete page in one language (preferably the team's primary language)\n2. **Preserved context**: AI can see the complete page and understand the visual, functional, and user context\n3. **Contextual translation**: AI generates translations that maintain coherence with design and functionality\n4. **Rapid iteration**: We can adjust and improve translations more efficiently\n\n## Advantages of the new approach\n\n### 1. Complete context until the last moment\n\nThe greatest advantage is that we maintain visual and functional context until the moment of translation. Instead of working with keys like `\"button.accept\"` or `\"error.validation\"`, AI can see exactly how each text is used in the interface.\n\n### 2. Better translation quality\n\nAI can generate more natural and contextually appropriate translations because it understands:\n\n- The purpose of each element (button, error, label)\n- The visual hierarchy of information\n- The user interaction flow\n- The general tone and style of the application\n\n### 3. Automatic consistency\n\nAI can maintain consistency in:\n\n- Technical terminology\n- Communication tone\n- Writing style\n- Interface conventions\n\n## Challenges and considerations\n\n### Let AI create the hierarchy or do it manually?\n\nThis is a crucial point that requires reflection. Traditionally, we extracted patterns to create translation hierarchies:\n\n```typescript\n// Traditional approach\nconst translations = {\n  buttons: {\n    accept: \"Accept\",\n    cancel: \"Cancel\",\n    save: \"Save\",\n  },\n  errors: {\n    validation: \"Validation error\",\n    network: \"Connection error\",\n  },\n};\n```\n\nWith AI, we have two options:\n\n#### Option 1: AI generates the structure\n\nLet AI propose the organization of translations based on patterns it detects.\n\n**Advantages:**\n\n- Less manual work\n- Automatic pattern detection\n- Adaptation to new contexts\n\n**Disadvantages:**\n\n- Less control over structure\n- Possible inconsistencies in organization\n- Difficult to maintain long-term\n\n#### Option 2: Manual structure with AI guidance\n\nDefine patterns and structure, but use AI to generate content.\n\n**Advantages:**\n\n- Total control over organization\n- Consistency in structure\n- Easier to maintain\n\n**Disadvantages:**\n\n- Requires more initial work\n- Less flexibility for changes\n\n## Recommended patterns to guide AI\n\n### 1. Error centralization\n\nErrors should be centralized in a single place to facilitate their management and translation:\n\n```typescript\n// Recommended structure\nconst errorMessages = {\n  validation: {\n    required: \"This field is required\",\n    email: \"Invalid email format\",\n    minLength: \"Minimum {length} characters\",\n  },\n  network: {\n    timeout: \"Request timeout\",\n    serverError: \"Server error\",\n  },\n};\n```\n\n### 2. Reuse of common elements\n\nElements like buttons, links, and navigation texts should be reusable:\n\n```typescript\nconst commonElements = {\n  buttons: {\n    primary: \"Continue\",\n    secondary: \"Cancel\",\n    danger: \"Delete\",\n  },\n  navigation: {\n    back: \"Back\",\n    next: \"Next\",\n    home: \"Home\",\n  },\n};\n```\n\n### 3. Interpolation patterns\n\nDefine clear patterns for variable interpolation:\n\n```typescript\nconst patterns = {\n  welcome: \"Welcome, {name}\",\n  itemsCount: \"{count} items\",\n  progress: \"{current} of {total}\",\n};\n```\n\n## Conclusions\n\nAI is transforming internationalization from a mechanical and error-prone task to a more intelligent and contextual process. The key is finding the balance between automation and manual control.\n\n**The fundamental principles are:**\n\n- Maintain context until the last moment\n- Define clear patterns for reuse\n- Use AI as a tool, not as a replacement\n- Iterate and continuously improve the process\n\nThe future of i18n with AI is not about completely replacing manual work, but about making it more efficient, contextual, and of higher quality.\n",
    "path": "/en/blog/ai-take-aways/i18n",
    "id": "en/ai-take-aways/i18n"
  },
  {
    "title": "CSS: Load Strategies",
    "description": "Practical guide on CSS loading: render blocking, strategies (preload, media, inline) and web performance.",
    "pubDate": "2025-08-23T00:00:00.000Z",
    "tags": [
      "css",
      "performance",
      "wpo"
    ],
    "categories": [
      "css",
      "best-practices"
    ],
    "draft": false,
    "heroImage": "/blog-placeholder-26.png",
    "content": "## Why is it important to know how CSS is loaded?\n\nWe might think it is because of the weight (many bytes to send to the client), but the answer is simpler, because it **blocks the browser rendering**.\n\n### **CSS loading diagram**\n\n![css-load](/css-load.drawio.png)\n\n- **HTML Parser:**<br>\n  This is the first step, where the browser analyzes the HTML document to create the DOM.\n- **CSS Parser:**<br>\n  When the HTML parser encounters CSS style sheets, it passes them to the CSS parser.\n- **CSSOM (CSS Object Model):**<br>The CSS parser creates the CSSOM, a tree-like structure that represents the styles of the document.\n- **DOM:**<br>The HTML parser creates this tree structure of the HTML document.\n- **Render Tree:**<br>It is the rendering from the combination of the DOM and the CSSOM. This tree includes only the visible elements and their computed styles and applies the cascade rules at the same time.\n- **Cascade Rules:**<br> This is where the browser applies the cascade, specificity, and inheritance rules of CSS to determine the final styles of each element.\n- **Final Computed Style:**<br> It is the final result for each element, showing all applied styles, which is used for subsequent Layout/reflow and Paint steps.\n\n### **Ways to Load CSS**\n\n#### **External** (`<link ...>`)\n\n<br>\n\n```html\n<head>\n  <!-- Blocking load by default -->\n  <link rel=\"stylesheet\" href=\"/assets/styles.css\" />\n</head>\n```\n\n**Notes:**\n\n- **Blocks the first render** until `styles.css` is parsed.\n- To mitigate this, we could limit it by media by taking out print styles for example.\n\n```html\n<link rel=\"stylesheet\" href=\"/assets/print.css\" media=\"print\" />\n```\n\n#### Internal (`<style>`)\n\n<hr>\n\n```html\n<head>\n  <style>\n    :root {\n      --brand: #0a66c2;\n    }\n    body {\n      color: var(--brand);\n    }\n  </style>\n</head>\n```\n\n**Notes:**\n\n- It is parsed in situ.\n- Useful for small critical CSS.\n\n#### Inline (in the style attribute)\n\n<hr>\n\n```html\n<div style=\"color: tomato; font-weight: 600\">Text with inline style</div>\n```\n\n**Notes:**\n\n- Maximum precedence (except for `!important`).\n- Not cacheable\n- Not reusable (HTML can be cached but parsing has to be done again)\n\n#### Imported within another CSS (`@import`)\n\n<hr>\n\n```css\n/* main.css */\n@import url(\"/assets/base.css\");\n@import url(\"/assets/theme.css\") screen and (min-width: 48rem);\n\n.container {\n  margin-inline: auto;\n}\n```\n\nOr from `<style>`:\n\n```html\n<style>\n  @import url(\"/assets/base.css\");\n  body {\n    font-family: system-ui;\n  }\n</style>\n```\n\n**Notes:**\n\n- Evaluated in order of appearance.\n- Penalizes performance\n  - **Chain request**\n  - Generates new server requests.\n- **Serious security issues**, they can steal your user passwords with a simple CSS\n- If after this you want to continue using it I suppose it's because you like risk. I had a phrase when I was young for when I did crazy things\n  > Commander Salamander: Too fast to live, too young to die\"\n\n#### Dynamically by JS (injecting `<link>` or `<style>`)\n\n<hr>\n\n```html\n<!-- **Insert dynamic link (lazy styles)** -->\n<script>\n  const link = document.createElement(\"link\");\n  link.rel = \"stylesheet\";\n  link.href = \"/assets/chunk-above-the-fold.css\";\n  document.head.appendChild(link);\n</script>\n```\n\n```html\n<!-- **Insert style with rules (generated or feature‑flag)** -->\n<script>\n  const style = document.createElement(\"style\");\n  style.textContent = `\n    .promo { display: grid; gap: 0.5rem; }\n    @media (prefers-color-scheme: dark) {\n      .promo { color: white; }\n    }\n  `;\n  document.head.appendChild(style);\n</script>\n```\n\n**Notes:**\n\n- Applied after parsing/attaching.\n- Useful for style code‑splitting or runtime theming.\n\n### In summary\n\nIf we look at the blocks, differentiating between **network block** (latency/download) and **parse/render block** (the parser stops while processing rules), we would have something like this:\n\n| Charging Form               | Network Block | Parse/Render Block | Notes                                                                 |\n| --------------------------- | -------------- | ------------------ | --------------------------------------------------------------------- |\n| **External Sheet (link)**   | ✅ Yes         | ✅ Yes (until integrate) | Wait to download → parse → integrate in CSSOM. Blocks FCP/LCP.        |\n| **Internal (style)**       | ❌ No          | ✅ Yes (minimum)    | It is parsed inline in the HTML. No network wait, only local CPU.    |\n| **Inline (style attribute)** | ❌ No          | ✅ Yes (when applied)      | Applied instantly to the element. Minimal cost per specific rule.    |\n| **@import in CSS**          | ✅ Yes (extra) | ✅ Yes              | **Worst case:** chain download → each import blocks the next one.     |\n| **Dynamic (JS)**            | ✅ Yes         | ❌ No (async)          | Downloaded when inserting the `<link>`/`<style>`. Does not block the parser. |\n\n**Conclusion**\n\n- What really kills your render are the **synchronous external downloads** (link + import).\n- Inline and internal only stop the parser locally (usually irrelevant except for huge CSS).\n- **Dynamic does not block the parser** because it happens later, but**delays the application of styles** until it is downloaded/applied (AKA FOUC → Flash of Unstyled Content).\n\n---\n\n### Extra ball: Known strategies to minimize blocking\n\n- Inline Critical CSS for the above-the-fold.\n- `preload` of the main CSS and apply as a stylesheet when it loads.\n- Defer of non-critical CSS with `media` and `onload` (the old JavaScript trick).\n- Split CSS by route or layout.\n\n### Preload + swap (advance downloading; apply after `onload`)\n\n```html\n<link\n  rel=\"preload\"\n  as=\"style\"\n  href=\"/assets/late.css\"\n  onload=\"this.rel='stylesheet'\"\n/>\n<noscript><link rel=\"stylesheet\" href=\"/assets/late.css\" /></noscript>\n```\n\n**notes:**\n\n- Doesn't apply styles until onload (avoids blocking the first render).\n- You must maintain a fallback in `<noscript>` just in case.\n\n### Media to load without blocking and activate later\n\n```html\n<link\n  rel=\"stylesheet\"\n  href=\"/assets/print.css\"\n  media=\"print\"\n  onload=\"this.media='all'\"\n/>\n```\n\n- It downloads in the background\n- It activates when you change media to `all` .\n",
    "path": "/en/blog/css-load",
    "id": "en/css-load"
  },
  {
    "title": "particle system",
    "pubDate": "2019-01-11T00:00:00.000Z",
    "description": "Exploring particle system animation techniques using Canvas and JavaScript for creating dynamic visual effects",
    "tags": [
      "particle system"
    ],
    "categories": [
      "experiment"
    ],
    "draft": false,
    "heroImage": "/blog-placeholder-11.jpg",
    "content": "\n<script type=\"module\" src=\"/js/experiments/system01.js\"></script>\n\n<canvas></canvas>\n",
    "path": "/en/blog/experiments/particle-system-01",
    "id": "en/experiments/particle-system-01"
  },
  {
    "title": "Hindley-Milner notation",
    "description": "Understanding Hindley-Milner type notation in functional programming for expressing function signatures and type relationships",
    "pubDate": "2019-04-11",
    "tags": [
      "declarative",
      "Pure functions",
      "Inmutable",
      "currying",
      "Hindley-Milner"
    ],
    "categories": [
      "functional"
    ],
    "draft": false,
    "heroImage": "/blog-placeholder-13.jpg",
    "content": "\nA way to create a notation to express what types of parameter a function takes, and what it returns.\n\n## The basic\n\nA function that takes a primary value (\"old type\" like string, number, boolean, array, function...) and returns another primary value:\n\n`instruction :: String -> String`\n\n```javascript\nconst instruction = function (verb) {\n  return verb + \" me\";\n};\n```\n\nthe function instruction takes a string and return a string\n\nYou could also do something like:\n\n`length :: String → Number`\n\n```javascript\nconst length = function (s) {\n  return s.length;\n};\n```\n\nIn the case of an array of numbers:\n\n`length :: [Number] → Number`\n\n```javascript\n    const length = function(arr){\n        retrun arr.length\n    }\n```\n\n## Working with functions\n\nIn the case of a function, we wrap our function in parenthesis and inside the parenthesis we have our input type and our output type:\n\n`addOneToAll :: ((Number → Number),[Number]) → [Number]`\n\n```javascript\nconst addOne = function (x) {\n  return x + 1;\n};\nconst addOneToAll = (addOne, arr) => arr.map(addOne);\n```\n\nIn this case we have a function call addOneToAll that expects as first parameter a function (in our case addOne) and this function will accept a number and returns a nunmber.\nAnd as a second parameter an array of numers and will return another array of numbers.\n\n### Currying functions\n\nNow what about a function that returns a function that returns another function ....\n\nFollowing above we will have something like this:\n`replace :: String -> (String -> (String -> String))`\n\n```javascript\nvar replace = curry(function (find, replacement, str) {\n  var regex = new RegExp(find, \"g\");\n  return str.replace(regex, replacement);\n});\n```\n\nIn this case we also curryfy the function in order to take parameters one by one\n\nAnd in functional programming we can assuming that everything is curried, so we tend to drop the brackets and something like this:\n\n` replace :: String -> String -> String -> String`\n\n## Working with functions that takes multiple parameters as input (Hindley-Milner's Arbitrary Variables)\n\nWe show the example with the length function were we could have:\n`length :: [Number] → Number`\nor\n`length :: string → Number`\n\nIn this case we could write both with an arbitrary variable like:\n`length :: [a] → Number`\n\nAnother common example is the identity:\n`identity :: a -> a`\n\nAnd a more complex example:\n`map :: (a -> b) -> [a] -> [b]`\n\n```javascript\nconst map = curry(function (callback, array) {\n  return array.map(callback);\n});\n```\n\nThe map function takes a function that takes a variable of type `a` and returns a variable of type `b`.\nThen takes an **array of values**, all type `a`, and returns an **array of values**, all type `b`.\n\n---\n\n## Working with Ramda\n\n## Parametrized Types\n\nWe can easily imagine a type representing a collection of similar items,\nlet's call it a Box. But no instance is an arbitrary Box; each one can only hold one sort of item.\n\n`makeBox :: Number -> Number -> Number -> [a] -> Box a`\n\n```javascript\n  const makeBox = curry((height, width, depth, items) => /* ... */);\n```\n\n## Type Aliases\n\nIf we had a parameterized type User String, where the String was meant to represent a name, and we wanted to be more specific about the type of String that is represented when generating a URL, we could create a type alias like this:\n\n`toUrl :: User Name u => Url -> u -> Url`\n\n`Name = String`\n\n` Url = String`\n\n```javascript\nconst toUrl = curry(\n  (base, user) => base + user.name.toLowerCase().replace(/\\W/g, \"-\")\n);\ntoUrl(\"http://example.com/users/\", { name: \"Fred Flintstone\", age: 24 });\n//=> 'http://example.com/users/fred-flintstone'\n```\n\n## Type constrains [Ord]\n\nSometimes we want to restrict the generic types we can use in a signature in some way or another\n\nWe might want a maximum function that can operate on Numbers, on Strings, on Dates, but not on arbitrary Objects.\n\nWe want to describe ordered types, ones for which **a < b will always return a meaningful result**\n\n`maximum :: Ord a => [a] -> a`\n\n```javascript\nconst maximum = (vals) =>\n  reduce((curr, next) => (next > curr ? next : curr), head(vals), tail(vals));\nmaximum([3, 1, 4, 1]); //=> 4\nmaximum([\"foo\", \"bar\", \"baz\", \"qux\", \"quux\"]); //=> 'qux'\nmaximum([\n  new Date(\"1867-07-01\"),\n  new Date(\"1810-09-16\"),\n  new Date(\"1776-07-04\"),\n]); //=> new Date(\"1867-07-01\")\n```\n\n`Ord a ⇒ [a] → a` says that maximum takes a collection of elements of some type, but that type must adhere to Ord.\n\nIn JS, there's no way to guarantee that the user will not pass us [1, 2, 'a', false, undefined, null].\nSo our entire type annotation is **descriptive and aspirational** rather than compiler-enforced, as it would be in, say, Haskell.\n\n## Multiple Signatures\n\nSometimes rather than trying to find the most generic version of a signature, it's more straightforward to list several related signatures separately.\nWe could do that like bellow:\n\n`getIndex :: a -> [a] -> Number`\n`:: String -> String -> Number`\n\n```javascript\nconst getIndex = curry((needle, haystack) => haystack.indexOf(needle));\ngetIndex(\"ba\", \"foobar\"); //=> 3\ngetIndex(42, [7, 14, 21, 28, 35, 42, 49]); //=> 5\n```\n\n## Variadic Functions (specific to Ramda)\n\nIn Haskell, all functions have a fixed arity. But Javsacript has to deal with variadic functions.\n`flip :: (a -> b -> ... -> z) -> (b -> a -> ... -> z)`\n\n```javascript\nconst flip = (fn) =>\n  function (b, a) {\n    return fn.apply(this, [a, b].concat([].slice.call(arguments, 2)));\n  };\nflip((x, y, z) => x + y + z)(\"a\", \"b\", \"c\"); //=> 'bac'\n```\n\n## Simple Objects\n\nWhen an object is used as a dictionary of like-typed values (as opposed to its other role as a Record), then the types of the keys and the values can become relevant.\nSo we could represent them like this:\n`keys :: {k: v} -> [k]`\n`values :: {k: v} ->  [v]`\n\n```javascript\nkeys({ a: 86, b: 75, c: 309 }); //=> ['a', 'b', 'c']\nvalues({ a: 86, b: 75, c: 309 }); //=> [86, 75, 309]\n```\n\n## Complex example\n\n`Lens s a -> (a -> a) -> s -> s`\n`Lens s a = Functor f => (a -> f a) -> s -> f s`\n\nWe start with the type alias, Lens s a = Functor f ⇒ (a → f a) → s → f s.\nThis tells us that the type Lens **is parameterized by two generic variables, s, and a**.\nWe know that there is a constraint on the type of the f variable used in a Lens: **it must be a Functor**.\nWith that in mind, we see that a Lens is a curried function of two parameters, the first being a function from\na value of the generic type a to one of the parameterized type f a, and the second being a value of generic type s.\n\n**The result** is a value of the parameterized type `f・s`\n\n<div class=\"bibliography\">\nBibliogrphy:<br><br>\n\n- [gentle introduction to functional javascript style](https://jrsinclair.com/articles/2016/gentle-introduction-to-functional-javascript-style#hindley-milnertypesignatures)\n- [function type signatures in Javascript](https://hackernoon.com/function-type-signatures-in-javascript-5c698c1e9801)\n- [Type signatures in Ramda](https://github.com/ramda/ramda/wiki/Type-Signatures)\n</div>\n",
    "path": "/en/blog/functional/hindley-milner-notation",
    "id": "en/functional/hindley-milner-notation"
  },
  {
    "title": "combinators",
    "description": "Understanding combinators in functional programming as higher-order pure functions for composing and controlling program flow",
    "pubDate": "2019-01-10",
    "tags": [
      "declarative",
      "Pure functions",
      "Inmutable",
      "currying",
      "combinator"
    ],
    "categories": [
      "functional"
    ],
    "draft": false,
    "heroImage": "/blog-placeholder-10.jpg",
    "content": "\nA combinator are higher-order , **pure functions** that doesn't have any **free variable** and\ncan combine primitive artifacts like other functions (or other combinators) and behave as control logic.\n\n**Free variables** are just simple variables in the context of a function that aren't explicit\npass in as argument.\n\nOur commitment is that all dependencies are pass by parameter.\n\nCombinators unlock freedom and facilitate point-free programming.\nBecause combinators are pure, they can be composed into other combinators,\nproviding an infinite number of alternatives to express and reduce the complexity of writing\nany type of application.\n\nFor example a composer function will be a combinator:\n\n```javascript\nconst compose = (f, g) => (x) => f(g(x));\n\nconst addTwo = (x) => x + 2;\nconst multByTree = (x) => x * 3;\n\nconst operator = compose(addTwo, multByTree);\n\nconsole.log(operator(7)); // 23\n// NOTE: remember that  compose will execute from right to left\n```\n\nIn Ramda there are many combinators that we can use:\n\n- compose\n- pipe\n- identity\n- tap\n- alternation\n- sequence\n- fork (join)\n\n## identity\n\nThe identity combinator is a function that returns the same value it was provided as an argument:\n\n`identity :: (a) -> a`\n\nIt's used extensively when examining the mathematical properties of functions,\nbut it has other practical applications as well:\n\n- Supplying data to higher-order functions that expect it when evaluating a function argument.\n- Unit testing the flow of function combinators where you need a simple function result on which\n  to make assertions.\n- Extracting data functionally from encapsulated types.\n\n## Tap\n\ntap is extremely useful to bridge void functions (such as logging or writing a file or an HTML page)\ninto your composition without having to any create additional code. It does this by passing itself\ninto a function and returning itself. Here's the function signature:\n\n`tap :: (a -> *) -> a -> a`\n\n## Alternation [OR - combinator]\n\nThe alt combinator allows you to perform **simple conditional logic** when providing default\nbehavior in response to a function call.\nThis combinator takes two functions and returns the result of the first one if the value is\ndefined (not false, null, or undefined); otherwise, it returns the result of the second function.\n\n## Sequence (S-combinator)\n\nThe seq combinator is used to loop over a sequence of functions. It takes two or more functions\nas parameters and returns a new function, which runs all of them in sequence against the same value.\n\nThe seq combinator doesn't return a value; it just performs a set of actions one after the other.\n\n## Fork (join) combinator\n\nThe fork combinator is useful in cases where you need to process a single resource in two\ndifferent ways and then combine the results.\n\n<br><br>\n\n<div class=\"bibliography\">\n\n## Bibliografía:\n\n- Functional Programming in JavaScript . Ed: MANNING SHELTER ISLAND. Author: Luis Atencio.<br>\n- [Mostly Adequate Guide to functional programming](https://drboolean.gitbooks.io/mostly-adequate-guide-old/content/).\n  Professor Frisby's<br>\n- [Building a declarative app using Functional javaScript](https://www.packtpub.com/web-development/building-declarative-apps-using-functional-javascript-video).\n  Michael Rosata\n  </div>\n",
    "path": "/en/blog/functional/combinators",
    "id": "en/functional/combinators"
  },
  {
    "title": "functional programming",
    "description": "An introduction to functional programming concepts including declarative programming, pure functions, immutability, and currying",
    "pubDate": "2018-01-12",
    "tags": [
      "declarative",
      "Pure functions",
      "Inmutable",
      "currying"
    ],
    "categories": [
      "functional"
    ],
    "draft": false,
    "heroImage": "/blog-placeholder-12.jpg",
    "content": "\nIn computer science, functional programming is a programming paradigm — a style of building the structure and elements of computer programs— that treats computation as the **evaluation of mathematical functions and avoids changing-state and mutable data**.\n\nIt is a **declarative** programming paradigm, which means programming is done with expressions or declarations instead of statements. To put it in a diferent way we can say that\n**declarative programming cares about what** to perform an action and imperative cares about how to perform that action\n\n## Declarative Vs. Imperative || What Vs. How\n\nIn functional code, the output value of a function depends only on the arguments that are passed to the function, so calling a function f twice with the same value for an argument x produces the same result f(x) each time; this is in contrast to procedures depending on a local or global state, which may produce different results at different times when called with the same arguments but a different program state. Eliminating side effects, i.e., changes in state that do not depend on the function inputs, can make it much easier to understand and predict the behavior of a program, which is one of the key motivations for the development of functional programming.\n\nIn contrast, imperative programming changes state with commands in the source code, the simplest example being assignment. Imperative programming does have functions—not in the mathematical sense—but in the sense of subroutines. They can have side effects that may change the value of program state. Functions without return values therefore make sense. Because of this, they lack referential transparency, i.e., the same language expression can result in different values at different times depending on the state of the executing program.\n\n**IMPERATIVE**\n\n```javascript\nfor (var i = 0; i < users.length; i++) {\n  users[i].lastModified = new Date();\n}\n```\n\n**DECLARATIVE**\n\n```javascript\nusers.mnap((u) => {\n  u.lastModified = new Date();\n  return u;\n});\n```\n\n## Mathematical Functions ( Pure Functions)\n\nFunctions that with the same input always return the same output. They don't deppend in any other data other than what is passed to the funtion and don't alter dataother than what they returned\n\n## Mutable data\n\nMutable data is data that can be change.\nAn example will be to order an array. If we have an unorder array and we create a function that shorts that array if the function return a new array with the shorting this will be unmutable data because we did not change the original array, but if the function takes our initial array and modify it then the data is mutable and we will loose the original reference of the array and we can have side effects\n\n## Working with array Functions\n\n```javascript\n// Returns the value of the first element in an array that pass a test\nusers.find((u) => {\n  return u.id === id;\n});\n// Checks if every element in an array pass a test\nusers.every((u) => {\n  return u.isAdmin;\n});\n// Checks if any of the elements in an array pass a test\nusers.some((u) => {\n  return u.isAdmin;\n});\n// Creates a new array with every element in an array that pass a test\nusers.filter((u) => {\n  return u.isAdmin;\n});\n// Creates a new array with the result of calling a function for each array element\nusers.map((u) => {\n  u.updated = new Date();\n  return u;\n});\n// Reduce the values of an array to a single value (going left-to-right)\nusers.reduce((accumulator, n) => {\n  return accumulator + n;\n}, 0);\n```\n\n## Chaining\n\nExercise: For a given array of numer we what to:\n\n1.  reduce every value by 1.\n2.  summ all resulting values that are divisible by 3\n\nSolution:\n\n**IMPERATIVE**\n\n```javascript\n// given array\nlet numbers = [2, 4, 10, 12, 19, 23];\nlet sum = 0;\n\nfor (let i = 0; i < numbers.length; i++) {\n  numbers[i] = numbers[i] - 1;\n  if (numbers[i] % 3 == 0) {\n    sum += numbers[i];\n  }\n}\n\nconsole.log(sum); // sum = 30;\n```\n\n**DECLARATIVE**\n\n```javascript\n// given array\n// given array\nlet numbers = [2, 4, 10, 12, 19, 23];\n\nlet substractOne = (n) => n - 1;\nlet isDivisbleBy3 = (n) => (n % 3 === 0 ? n : null);\nlet add = (n, i) => n + i;\n\nlet sum = numbers.map(substractOne).filter(isDivisbleBy3).reduce(add, 0);\n\nconsole.log(sum); // sum = 30;\n```\n\n## Currying\n\nConvert a function that accepts multiple parameters into a series of functions that each only take 1 parameter\n\nLet's see an example: <br>\n\n```javascript\n  // starting from\n  users.find((u) => {\n    return u.id === id;\n  });\n\n// now we could do soomethig like:\n\nconst byId = (item) => {\n  return item.id === id;\n}\n\nusers.find(byId)\n\n// the problem with the above code is that id will be undefined since we need 2 params and we are passing only one\n\n// the solution will be a function that returns another function\nconst byId = (id) => {\n  return (item) => {\n    return item.id === id;\n  }\n}\n\nusers.find(byId(2))\n\n// So this also means that you could use byId in any place and you can call it like:\nbyId(2)(users)\n\n// Ramda has a curry function that does currying\n\nconst byId = R.curry(id, item) {\n  return item.id === id;\n}\n\nusers.find(byId(2))\n\n// also de advantage of using the R.curry funtion is that it accepts more than 2 parameters\n// for example:\n\nconst add = R.curry((a,b,c,) => {\n  return a + b + c;\n})\n\nadd(1)(2)(3);\n\n\n```\n\nThis is another example\n\n```javascript\nconst convertUnits =\n  (toUnit, factor, offset = 0) =>\n  (input) =>\n    ((offset + input) * factor).toFixed(2).concat(toUnit);\n\nconst milesToKm = convertUnits(\"km\", 1.60936, 0);\nconst poundsToKg = convertUnits(\"kg\", 0.4546, 0);\nconst farenheitToCelsius = convertUnits(\"degrees C\", 0.5556, -32);\n\nmilesToKm(10); //\"16.09 km\"\npoundsToKg(2.5); //\"1.14 kg\"\nfarenheitToCelsius(98); //\"36.67 degrees C\"\n\nconst weightsInPounds = [5, 15.4, 9.8, 110];\n\n// without currying\n// const weightsInKg = weightsInPounds.map(x => convertUnits('kg', 0.45460, 0)(x));\n\n// with currying\nconst weightsInKg = weightsInPounds.map(poundsToKg);\n// 2.27kg, 7.00kg, 4.46kg, 50.01kg\n```\n\n## Partial application\n\nSupplying less arguments than required\n\n<div class=\"bibliography\">\nBibliography:\n\n- Wikipedia: https://en.wikipedia.org/wiki/Functional_programming <br>\n- Pluralsite video: [(Fundamentals of Functional Programming in JavaScript by Nate Taylor)](https://app.pluralsight.com/library/courses/javascript-functional-programming-fundamentals/exercise-files)<br>\n- w3School: [JavaScript Array Reference](https://www.w3schools.com/jsref/jsref_obj_array.asp)\n</div>\n",
    "path": "/en/blog/functional/functional-programming",
    "id": "en/functional/functional-programming"
  },
  {
    "title": "programming functors",
    "description": "Understanding functors as a design pattern for safely manipulating wrapped values in functional programming",
    "pubDate": "2019-01-01",
    "tags": [
      "declarative",
      "Pure functions",
      "Inmutable",
      "currying"
    ],
    "categories": [
      "functional"
    ],
    "draft": false,
    "heroImage": "/blog-placeholder-15.jpg",
    "content": "\n> **Functor is simply an interface with a contract.**<br>\n> We could have just as easily named it Mappable, but now, where's the fun in that?.<br> > _Professor Frisby's_\n\nA functor is nothing more than a data structure that you can map functions with the purpose of\nlifting values intro a wrapper, modifying them, and then putting them back into a wrapper.\n\nIt is a design pattern that defines semantics for how **fmap** should work\n\n` fmap :: (A -> B) -> Wrapper(A) -> Wrapper(B)`\n\nLet's see an example:\n\n```javascript\n// NOTE: we can't use arrow function if we are referencing this inside the function (no \"new\" for arrow functions)\nvar Container = function (x) {\n  this.__value = x;\n};\n\nContainer.of = function (x) {\n  return new Container(x);\n};\n\nContainer.of(3); // => Contaier(3) === { \"__value\": 3 }\nContainer.of(Container.of(\"pepinillos\")); // => Container(Container(\"pepinillos\")) === { \"__value\": { \"__value\": \"pepinillos\" } }\n```\n\n- `Container` is an object with one property.\n\n- Lots of containers just hold one thing, though they aren't limited to one.\n  We've arbitrarily named its property `__value`.\n\n- The `__value` cannot be one specific type or our `container` would hardly live up to the name.\n\n- Once data goes into the `Container` it stays there. We could get it out by using `.__value` , but that would defeat the purpose.\n\n---\n\nSo now let's recap again about the idea of a functor. What is a functor and what a functor should have.\n\nA functor will be mainly a container, and why do we want to do that?, well containerizing (or wrapping) values is a fundamental design pattern in functional programming\nbecause it **guards direct access to the values** so they can be manipulated safely and immutably in your programs.\n\n```javascript\nclass Wrapper {\n  constructor(value) {\n    this._value = value;\n  }\n\n  toString() {\n    return \"Wrapper (\" + this._value + \")\";\n  }\n}\n\n// wrap :: A -> Wrapper(A)\nconst wrap = (val) => new Wrapper(val);\nwrap(\"Hello Muzzy\").toString(); // -> Wrapper (Hellow Muzzy)\n```\n\nNow that we have a container for our values we need something to operate those values , because accessing a wrapped value can only be done by **mapping an operation to its container**.\n\nSo a functor must be a wrapped object and a function to **map** over the values, in functional world they use to call this function **map** or **fmap**\n\n```javascript\nclass Wrapper {\n  constructor(value) {\n    this._value = value;\n  }\n  toString() {\n    return \"Wrapper (\" + this._value + \")\";\n  }\n\n  // map :: (A -> B) -> A -> B\n  map(fn) {\n    return fn(this._value);\n  }\n}\n// wrap :: A -> Wrapper(A)\nconst wrap = (val) => new Wrapper(val);\nwrap(\"Hello Muzzy\").toString(); // -> Wrapper (Hellow Muzzy)\nwrap(\"Hello Muzzy\").map((item) => item.toUpperCase()); // --> HELLOW MUZZY\n```\n\nIn the above example we are mapping over the value but the problem is that we are returning the value transformed already , witch is ok but we cannot chain any thing else withing this container\nand we loose the ability to box our data because we exit our \"safe container\".\n\nSo maybe a good idea will be to return the mapped result into a new wrapper instead of returning only the result. So we change our function map into an **fmap**\n\n```javascript\nclass Wrapper {\n  constructor(value) {\n    this._value = value;\n  }\n  toString() {\n    return \"Wrapper (\" + this._value + \")\";\n  }\n\n  // fmap :: (A -> B) -> Wrapper[A] -> Wrapper[B]\n  fmap(fn) {\n    return new Wrapper(fn(this._value));\n  }\n}\n// wrap :: A -> Wrapper(A)\nconst wrap = (val) => new Wrapper(val);\nwrap(\"Hello Muzzy\").toString(); // -> Wrapper (Hellow Muzzy)\nwrap(\"Hello Muzzy\").fmap((item) => item.toUpperCase()); // --> Wrapper { _value: 'HELLO MUZZY' }\n```\n\nSo now we are returning a new Wrapper object with the value transformed after applying the mapped function (toUpperCase).\n\nfmap knows how to apply functions to values wrapped in a context. It first opens the container,\nthen applies the given function to its value, and finally closes the value back into a new container of the **same type**.\n\nThis allows us to chain more actions within our wrapped value.\n\nSo imagine that we want to upper case and then split words into an array, we could easily do:\n\n```javascript\nclass Wrapper {\n  constructor(value) {\n    this._value = value;\n  }\n  toString() {\n    return \"Wrapper (\" + this._value + \")\";\n  }\n\n  // fmap :: (A -> B) -> Wrapper[A] -> Wrapper[B]\n  fmap(fn) {\n    return new Wrapper(fn(this._value));\n  }\n}\n// wrap :: A -> Wrapper(A)\nconst wrap = (val) => new Wrapper(val);\n\nwrap(\"Hello Muzzy\")\n  .fmap((item) => item.toUpperCase())\n  .fmap((item) => item.split(\" \")); // -->  Wrapper { _value: [ 'HELLO', 'MUZZY' ] }\n```\n\nThen after having an fmap function that returns the same type object we can also state that a functor will follow these two rules:\n\n1. **Preserves identity**\n\n```javascript\n    object.fmap(x => x) ≍ object\n```\n\n2. **Composable**\n\n```javascript\n    object.fmap(compose(f, g)) ≍ object.fmap(g).fmap(f)\n```\n\n<br>\n\nAn finally we can say then that an object will be a functor if it fulfills these rules:\n\n**1) It is a wrapper object to contain our data**<br>\n**2) had a map function to iterate over its own data**<br>\n**3) preserves identity**<br>\n**4) can be composable**<br><br>\n\n<hr>\n<div class=\"bibliography\">\nBibliogrphy:<br><br>\n\n- Functional Programming in JavaScript . Ed: MANNING SHELTER ISLAND. Author: Luis Atencio.\n- [Mostly Adequate Guide to functional programming](https://drboolean.gitbooks.io/mostly-adequate-guide-old/content/).\nProfessor Frisby's<br>\n</div>\n",
    "path": "/en/blog/functional/functors",
    "id": "en/functional/functors"
  },
  {
    "title": "Memoize",
    "description": "A more function memoizer",
    "pubDate": "2019-11-11",
    "tags": [
      "declarative",
      "Pure functions",
      "Inmutable",
      "currying",
      "functors"
    ],
    "categories": [
      "functional"
    ],
    "draft": false,
    "heroImage": "/blog-placeholder-9.jpg",
    "content": "\n```javascript\n// A more functional memoizer\n\n//We can beef up our module by adding functions later\nvar Memoizer = (function () {\n  //Private data\n  var cache = {};\n  //named functions are awesome!\n  function cacher(func) {\n    return function () {\n      var key = JSON.stringify(arguments);\n      if (cache[key]) {\n        return cache[key];\n      } else {\n        val = func.apply(this, arguments);\n        cache[key] = val;\n        return val;\n      }\n    };\n  }\n  //Public data\n  return {\n    memo: function (func) {\n      return cacher(func);\n    },\n  };\n})();\n\nvar fib = Memoizer.memo(function (n) {\n  if (n < 2) {\n    return 1;\n  } else {\n    return fib(n - 2) + fib(n - 1);\n  }\n});\n```\n",
    "path": "/en/blog/functional/memoize",
    "id": "en/functional/memoize"
  },
  {
    "title": "monads",
    "description": "Exploring monads as specialized functors for handling null data and streamlining error handling in functional programming",
    "pubDate": "2019-11-11",
    "tags": [
      "declarative",
      "Pure functions",
      "Inmutable",
      "currying",
      "functors"
    ],
    "categories": [
      "functional"
    ],
    "draft": false,
    "heroImage": "/blog-placeholder-8.jpg",
    "content": "\nSo let's remember first what's a functor:\n\n    1. It is a wrapper object to contain our data\n    2. had a map function to iterate over its own data\n    3. preserves identity\n    4. can be composable\n\nBut functors by themselves aren't compelling, because they're not expected to\nknow how to handle cases with **null data**.<br> `Ramda's R.compose`, for instance,\nwill break if a null function reference is passed into it. This isn't a flaw\nin the design; it's intentional.\n\n- Functors map functions of one type to another.\n\n- More-specialized behavior can be found in functional data types called monads.\n\n- Among other things, monads can streamline error handling in your code,allowing\n  you to write fluent function compositions.\n\n- What's their relationship to functors? **Monads are the containers\n  that functors \"reach into.\"**\n",
    "path": "/en/blog/functional/monads",
    "id": "en/functional/monads"
  },
  {
    "title": "transducers",
    "description": "Exploring transducers in functional programming for efficient data transformation pipelines without creating intermediate values",
    "pubDate": "2019-01-01",
    "tags": [
      "declarative",
      "Pure functions",
      "Inmutable",
      "currying",
      "functors",
      "transducers"
    ],
    "categories": [
      "functional"
    ],
    "draft": false,
    "heroImage": "/blog-placeholder-16.jpg",
    "content": "\nThe primary goal of transducers is to run a pipeline of transformations of an input stream of\nvalues **without creating intermediate values**. The functions describing computations are\ndecoupled, so this makes program design cleaner and easier to develop and maintain.\n\nA transducer is a function that accepts a transformer and returns a transformer and can be composed directly\n\nTransducers can:\n\n- Be Composable\n- They only enumerates over the elements **onces** (very efficient for working with data streams)\n- can be use for lazy or eager evaluation\n- You can combine transducer to generate another transducer (High order reducers ¿?)\n\nThere are two strategies:\n\n- **Pull:** lazy evaluation\n- **Push:** eager evaluation\n\n**Pull** waits until a consumer asks for the next value (for example an Iterable)\n\n**Push** enumerates over the source values and pushes them through the tubes ASAP (Array.reduce())\n\nTransducers compose top to bottom (left to right)\n\n**Example:**\n\nGiven an array of autobots we want to:\n\n1. ﬁlter out values that don't contain the letter 'r',\n2. uppercase\n3. reverse each value\n\n**First approach without a tranducer**\n\n```javascript\nconst R = require(\"ramda\"); // Ramda functional library\n\nlet autobots = [\n  \"Optimus Prime\",\n  \"Bumblebee\",\n  \"Ironhide\",\n  \"Sunstreaker\",\n  \"Ratchet\",\n];\n\n// Filter for autobots that contain 'r', uppercase, then reverse\nlet transform = R.compose(\n  R.filter((x) => /r/i.test(x)),\n  R.map(R.toUpper),\n  R.map(R.reverse)\n);\n\ntransform(autobots);\n// => [ 'EMIRP SUMITPO', 'EDIHNORI', 'REKAERTSNUS', 'TEHCTAR' ]\n```\n\n**Same approach with tranducer**\n\n```javascript\nconst R = require(\"ramda\"); // Ramda functional library\n\nlet autobots = [\n  \"Optimus Prime\",\n  \"Bumblebee\",\n  \"Ironhide\",\n  \"Sunstreaker\",\n  \"Ratchet\",\n];\n\n// Filter for autobots that contain 'r', uppercase, then reverse\nlet transform = R.compose(\n  R.filter((x) => /r/i.test(x)),\n  R.map(R.toUpper),\n  R.map(R.reverse)\n);\n\ntransform(autobots);\n// => [ 'EMIRP SUMITPO', 'EDIHNORI', 'REKAERTSNUS', 'TEHCTAR' ]\n```\n\nWe get the same exact result (in this situation), but something very different and very powerful\nis happening under the hood. **In the first example, the entire list was transformed at each step**.<br>\nThis means that we had to iterate over the list three times. However, **in the second example**\nwhere we used the transducer, **we only had to iterate over the list once!**\n\n<div class=\"bibliography\">\nBibliogrphy:<br><br>\n\n- [effectfulJS](https://github.com/awto/effectfuljs/tree/master/packages/transducers)\n- [Understanding Transducers in JavaScript](https://medium.com/@roman01la/understanding-transducers-in-javascript-3500d3bd9624)\n- [MAGICAL, MYSTICAL JAVASCRIPT TRANSDUCERS](https://jrsinclair.com/articles/2019/magical-mystical-js-transducers/)\n- [Transducers: Efficient Data Processing Pipelines in JavaScript](https://medium.com/javascript-scene/transducers-efficient-data-processing-pipelines-in-javascript-7985330fe73d).\n</div>\n",
    "path": "/en/blog/functional/transducers",
    "id": "en/functional/transducers"
  },
  {
    "title": "Global variables are bad",
    "description": "Exploring the dangers of global variables in JavaScript, including scope pollution, concurrency issues, and best practices for variable declaration",
    "pubDate": "2018-06-14",
    "tags": [
      "javascript",
      "globals"
    ],
    "categories": [
      "javascript"
    ],
    "draft": false,
    "heroImage": "/blog-placeholder-14.jpg",
    "content": "\n## Extracted from a Gist, a very nice explanation\n\n```javascript\n\n// It is important to declare your variables.\n\n(function() {\n    var foo = 'Hello, world!';\n    print(foo);  //=> Hello, world!\n})();\nprint(foo);  // No way José !!\n\n// Because if you don't, the become global variables.\n\n(function() {\n    foo = 'Hello, world!';\n    print(foo)  //=> Hello, world!\n})();\n\nprint(foo)  //=> WTF, it returns \"Hello, world!\"\n\n\n// When global variables sneak into your code they can cause problems.\n// Especially in applications with concurrency.\n\nvar count = function() {\n    for (i = 0; i < 10; i += 1) {\n        print(i);\n    }\n};\n\ncount();  //=> 0 1 2 3 4 5 6 7 8 9\n\nvar countSilently = function() {\n    for (i = 0; i < 10; i += 1) {\n        // don't print anything;\n    }\n};\n\n// Both loops increment i at the same time, which causes strange behavior.\nwindow.setTimeout(countSilently, 10);\nwindow.setTimeout(count,         10);  //=> 2 3 7 8 9\n\n\n// You can use 'this' in method definitions to refer to attributes of the\n// method's object.\n\nvar obj = {\n    name: 'foo',\n    introduce: function() {\n        print(this.name);\n    }\n};\n\nobj.introduce();  //=> foo\n\n// But 'this' does not follow the normal rules of scope in JavaScript. One\n// might expect 'this' to be available with the same value via closure in the\n// callback defined inside the method here.\n\nvar obj = {\n    name: 'foo',\n    introduce: function() {\n        window.setTimeout(function() {\n            print(this.name);\n        }, 3000);\n    }\n};\n\nobj.introduce(); //=> *pause* undefined\n\n// In fact, this got bound to the global object in the callback. To get around\n// this, assign the object reference to a regular variable that will have the\n// same value inside the callback definition.\n\nvar obj = {\n    name: 'foo',\n    introduce: function() {\n        var that = this;\n        window.setTimeout(function() {\n            print(that.name);\n        }, 3000);\n    }\n};\n\nobj.introduce();  //=> *pause* foo\n\n\n// The keyword 'this' is actually dynamically assigned whenever a function is\n// invoked. When a function is invoked as a method, i.e. obj.method(), 'this'\n// is bound to 'obj'. But when a function is invoked by itself 'this' is bound\n// to the global object.\n\nvar phrase = 'Hello, world!';\nvar printPhrase() {\n    print(this.phrase);\n}\n\nprintPhrase();  //=> Hello, world!\n\n// This is true even of functions that were defined as a method.\n\nvar obj = {\n    name: 'foo',\n    introduce: function() {\n        print(this.name);\n    }\n};\n\n// When the function is invoked without 'obj.' in front of it, 'this' becomes\n// the global namespace.\n\nvar introduce = obj.introduce;\nintroduce();  //=> undefined\n\n\n// Method invocation and function invocation are two of the invocation patterns\n// in JavaScript. A third is apply invocation, which gives us control over what\n// 'this' will be assigned to during function execution.\n\nintroduce.apply(obj, null);  //=> foo\n\n// 'apply' is a method on Function. The first argument is the value that 'this'\n// will be bound to. Successive arguments to apply are passed as arguments to\n// the function that is being invoked.\n\nvar chatty = function(repeatTimes) {\n    var i;\n    for (i = 0; i < repeatTimes; i += 1) {\n        print(this.name + ' ');\n    }\n}\nchatty.apply(obj, 3)  //=> foo foo foo\n\n\n// The fourth and final invocation pattern in JavaScript is constructor\n// invocation. This pattern was designed to provide a way to create new objects\n// that would appear familiar to programmers who are used to programming with\n// classes.\n\nvar Cat = function(name) {\n    this.name = name;\n};\nCat.prototype = {\n    query: function() {\n        print(this.name + ' says, \"meow\"');\n    }\n};\n\n// When a function is called with the 'new' keyword in front of it, a new\n// object is created and is bound to 'this' when the function runs. Special\n// constructor functions use this feature to customize new objects as they are\n// created.\n\nvar whiskers = new Cat('whiskers');\nwhiskers.query();  //=> whiskers says \"meow\"\n\n// When a new object is created with 'new', the prototype of the new object is\n// set to the prototype of the constructor function. So the new object inherits\n// all of the attributes of the constructor's prototype value. In this case,\n// new cat objects inherit the 'query' method from Cat.prototype.\n\nvar nibbler = new Cat('nibbler');\nnibbler.query();  //=> nibbler says \"meow\"\n\n\n// If a constructor function is called without the 'new' keyword, it is invoked\n// with the ordinary function invocation pattern.\n\nvar gotcha = Cat('gotcha!');\ngotcha.query();  //=> typein:165: TypeError: gotcha has no properties\n\n// So 'this' is assigned to the global object instead of to a newly created object. That means that any attributes assigned to the new object by the constructor function become global variables!\n\nprint(name);  //=> gotcha!\n\n\n// Constructor invocation is pretty complicated and prone to disastrous global\n// variable creation. Here is a cleaner way to create new objects that inherit\n// from other objects.\n\n// This defines Object.create, a method that simplifies the behavior of the\n// 'new' keyword. This method was invented by Douglas Crockford.\n// http://javascript.crockford.com/prototypal.html\nif (typeof Object.create !== 'function') {\n    Object.create = function(o) {\n        var F = function() {};\n        F.prototype = o;\n        return new F();\n    };\n}\n\n// Object.create(obj) returns a new object that inherits all of the attributes\n// of obj. The 'cat' prototype object here defines a 'clone' method that wraps\n// around Object.create to customize new 'cat' objects as they are created.\n\nvar cat = {\n    query: function() {\n        print(this.name + ' says \"meow\"');\n    },\n    clone: function(name) {\n        var newCat = Object.create(this);\n        newCat.name = name;\n        return newCat;\n    }\n};\n\nvar fluffy = cat.clone('fluffy');\nfluffy.query();  //=> fluffy says \"meow\"\n\n// In addition to inheriting 'query', new cats also inherit 'clone'.\n\nvar fluffy2 = fluffy.clone('fluffy2');\nfluffy2.query();  //=> fluffy2 says \"meow\"\n\n// Methods and attributes are inherited, not copied. If you change the\n// definition of 'clone' on 'cat' at this point, the change will be reflected\n// in cat objects that have already been created.\n\nfluffy2.hasOwnProperty('clone')  //=> false\nfluffy.hasOwnProperty('clone')  //=> false\ncat.hasOwnProperty('clone')  //=> true\n\n```\n\n<br>\n<div class=\"bibliography\">\n\n## Bibliografía:\n\nhttps://gist.github.com/hallettj/64478\n\n</div>\n",
    "path": "/en/blog/global-variables-are-bad",
    "id": "en/global-variables-are-bad"
  },
  {
    "title": "Lexical and Dynamic scope",
    "description": "Understanding lexical and dynamic scoping in JavaScript, including the eval keyword and its performance implications",
    "pubDate": "2018-01-14",
    "tags": [
      "scope",
      "eval",
      "javascript",
      "declarative"
    ],
    "categories": [
      "javascript"
    ],
    "draft": false,
    "heroImage": "/blog-placeholder-18.jpg",
    "content": "\n## Evil eval\n\nWe can cheat on lexical scoping using eval keywod. <br>\nThe eval keyword, takes any given strings and it treats as it was a code\n\n```javascript\nvar bar = \"foo\";\nfunction foo(str) {\n  eval(str);\n  console.log(\"bar\"); // 42 !!!!!\n}\n\nfoo(\"var bar = 42\");\n```\n\nThe problem of doing this is that performance will be afected because as we know JS first assign the LHS (left hand side), witch means that it will read all the assigments on the left and lator will do the right hand side of the code. In the case of the eval function we are using a RHS that contains a LHS and RHS statement and that means that JS compiler will not be able to do a code optimization because the engine cannot assume the lexical scoping to be unchange. So even if we declare an eval and not using it to do a declaration it will have a side effect on perfomance in our code.<br>\nSo to summarize in general we should not use eval key\n\n## with with\n\nWe can also skeep lexical scope by doing even a worse thing and that is using the with statement\n\n## A note about LHS and RHS\n\nLHS look-up is done when a variable appears on the left-hand side of an assignment operation, and an RHS look-up is done when a variable appears on the right-hand side of an assignment operation.\n\nI think of it as follows :<br>\nlhs lookup is a container lookup <br>\nrhs lookup is a value lookup<br>\n\n## Dynamic scope\n\nDynamic scope refers to a scoping mechanism where variables are resolved by searching up the call stack, rather than by the structure of the code (as in lexical scope). In dynamic scoping, the context in which a function is called determines the variable bindings, not where the function was defined.\n\nJavaScript uses lexical (static) scoping, but some behaviors—such as the value of `this`—can resemble dynamic scope because `this` is determined by how a function is invoked, not where it is written.\n\n### Example: Simulating Dynamic Scope with `this`\n\n```javascript\nvar name = \"global\";\n\nfunction printName() {\n  console.log(this.name);\n}\n\nvar obj = {\n  name: \"object\",\n  printName: printName,\n};\n\nprintName(); // \"global\" (this refers to global object)\nobj.printName(); // \"object\" (this refers to obj)\n```\n\nIn the example above, the value of `this` inside `printName` depends on how the function is called, not where it was defined. This is similar to dynamic scoping.\n\n### Key Differences\n\n- **Lexical scope**: Variable resolution is based on where functions and blocks are written in the code.\n- **Dynamic scope**: Variable resolution is based on the call stack at runtime.\n\nJavaScript does not have true dynamic scope for variables, but understanding how `this` and certain constructs work can help avoid confusion.\n\n---\n\n<div class=\"bibliography\">\n\n## Bibliografía:\n\nhttps://stackoverflow.com/questions/36383795/javascript-lhs-and-rhs-lookup<br>\nPlural sight course: Advanced javascript, by kyle Simpson\n\n</div>\n",
    "path": "/en/blog/lexical-and-dynamic-scope",
    "id": "en/lexical-and-dynamic-scope"
  },
  {
    "title": "Method chaining in javascript",
    "description": "Understanding method chaining in JavaScript for creating fluent interfaces and improving code readability through sequential method calls",
    "pubDate": "2018-01-08",
    "tags": [
      "javascript",
      "method chaining"
    ],
    "categories": [
      "javascript"
    ],
    "draft": false,
    "heroImage": "/blog-placeholder-20.jpg",
    "content": "\nfrom [wikipedia](https://en.wikipedia.org/wiki/Method_chaining) <br>\nMethod chaining, also known as named parameter idiom, is a common syntax for invoking multiple method calls in object-oriented programming languages.\n\nThe key to achieve this is that each method returns an object, allowing the calls to be chained together in a single statement without requiring variables to store the intermediate results.\n\nA similar syntax is method cascading, where after the method call the expression evaluates to the current object, not the return value of the method. Cascading can be implemented using method chaining by having the method return the current object itself. Cascading is a key technique in fluent interfaces, and since chaining is widely implemented in object-oriented languages while cascading isn't, this form of \"cascading-by-chaining by returning this\" is often referred to simply as \"chaining\". Both chaining and cascading come from the Smalltalk language.\n\nWhile chaining is syntax, it has semantic consequences, namely that requires methods to return an object, and if implementing cascading via chaining, this must be the current object. This prevents the return value from being used for some other purpose, such as returning an error value.\n\nTo see an example lest first define our use case:\n\nImagine that we have a class person that has some methods (or functions), these are:\n\n```javascript\nsetName();\nsetEyeColor();\nsetHairColor();\nsetHeight();\n```\n\nAnd this is the definition of our class\n\n```javascript\n// Definition of the class\n// ------------------------\nclass Person {\n  constructor() {\n    console.log(\"person created\");\n  }\n\n  setName(name) {\n    this.name = name;\n  }\n\n  setEyeColor(eyeColor) {\n    this.eyeColor = eyeColor;\n  }\n\n  setHairColor(hairColor) {\n    this.HairColor = hairColor;\n  }\n\n  setHeight(height) {\n    this.height = height;\n  }\n}\n```\n\nNow if we want to create a person and execute all methods we will do :\n\n```javascript\n// Execution\n// ---------\n\nvar pers = new Person();\npers.setName(\"Joe\");\npers.setEyeColor(\"blue\");\npers.setHairColor(\"black\");\npers.setHeight(\"1.75\");\n\nconsole.log(pers);\n```\n\nSo far so good.\n\nBut this could be improved doing method chaining. This way we will remove the call of pers object every time we want to execute a function of that object.\n<br/ >So our execution will be something like this:\n\n```javascript\nvar pers = new Person()\n  .setName(\"Joe\")\n  .setEyeColor(\"blue\")\n  .setHairColor(\"black\")\n  .setHeight(\"1.75\");\nconsole.log(pers);\n```\n\nOr better yet, we can apply some formating and also we don't even need to assign a var to person since we are doing method chaining , rewriting the above syntax as:\n\n```javascript\nconsole.log(\n  new Person()\n    .setName(\"Joe\")\n    .setEyeColor(\"blue\")\n    .setHairColor(\"black\")\n    .setHeight(\"1.75\")\n);\n```\n\nThe problem comes now because if we execute the above sentence we will end up with a compiler error.\nThis is because when we create a new person, none of the methods that we previously define are returning a value, so after the first method call the compiler does not know in what object to execute the next function.\n\nTo solve this we will need to redefine our methods to return the same object, like this\n\n```javascript\nclass Person {\n  constructor() {\n    console.log(\"person created\");\n  }\n\n  setName(name) {\n    this.name = name;\n    return this;\n  }\n\n  setEyeColor(eyeColor) {\n    this.eyeColor = eyeColor;\n    return this;\n  }\n\n  setHairColor(hairColor) {\n    this.HairColor = hairColor;\n    return this;\n  }\n\n  setHeight(height) {\n    this.height = height;\n    return this;\n  }\n}\n```\n\nAnd now we can do method chaining.\n\n```javascript\nconsole.log(\n  new Person()\n    .setName(\"Dina\")\n    .setEyeColor(\"black\")\n    .setHairColor(\"brown\")\n    .setHeight(\"1.85\")\n);\n\n// Person {HairColor:\"brown\", eyeColor:\"black\", height:\"1.85\", name:\"Dina\"}\n```\n",
    "path": "/en/blog/method-chaining-in-javascript",
    "id": "en/method-chaining-in-javascript"
  },
  {
    "title": "Object attribute properties",
    "description": "Exploring JavaScript object property attributes including value, configurable, enumerable, and writable flags",
    "pubDate": "2018-01-12",
    "tags": [
      "javascript",
      "object properties"
    ],
    "categories": [
      "javascript"
    ],
    "draft": false,
    "heroImage": "/blog-placeholder-19.jpg",
    "content": "\n# Understanding JavaScript Object Property Attributes\n\nJavaScript objects are fundamental to the language, and understanding their property attributes is essential for writing robust and maintainable code. In this article, we explore the four key property attributes in JavaScript: **value**, **configurable**, **enumerable**, and **writable**. Mastering these attributes allows you to control how object properties behave, which is crucial for advanced JavaScript development and object-oriented programming.\n\n## What Are Object Property Attributes in JavaScript?\n\nEvery property in a JavaScript object comes with a set of internal attributes that define its behavior. These attributes determine how the property can be accessed, modified, or enumerated. The four main property attributes are:\n\n### 1. value\n\nThe **value** attribute holds the actual data stored in the property. It can be any valid JavaScript value, such as a string, number, object, or function.\n\n### 2. configurable\n\nThe **configurable** attribute specifies whether the property can be deleted from the object or if its attributes (other than value and writable) can be changed. If set to `false`, you cannot delete the property or change its other attributes.\n\n### 3. enumerable\n\nThe **enumerable** attribute determines if the property will show up during property enumeration, such as in a `for...in` loop or when using `Object.keys()`.\n\n### 4. writable\n\nThe **writable** attribute controls whether the value of the property can be changed using assignment. If `writable` is set to `false`, attempts to modify the property will fail silently (in non-strict mode) or throw an error (in strict mode).\n\n## Why Are Property Attributes Important?\n\nUnderstanding and using property attributes in JavaScript allows you to:\n\n- Create immutable or read-only properties\n- Hide internal implementation details\n- Prevent accidental deletion or modification of critical properties\n- Fine-tune object behavior for security and maintainability\n\nYou can define or modify these attributes using `Object.defineProperty()` or `Object.defineProperties()`.\n\n## Example: Defining Property Attributes\n\n```js\nconst user = {};\nObject.defineProperty(user, \"id\", {\n  value: 123,\n  writable: false,\n  enumerable: true,\n  configurable: false,\n});\n```\n\nIn this example, the `id` property is read-only and cannot be deleted or reconfigured, but it will appear in enumerations.\n\n## Conclusion\n\nJavaScript object property attributes—**value**, **configurable**, **enumerable**, and **writable**—give you fine-grained control over your objects. Leveraging these attributes is a best practice for building secure, predictable, and maintainable JavaScript applications.\n\n---\n\n### References\n\n[Yeison Daza – Understanding Objects in JavaScript](https://medium.com/entendiendo-javascript/entendiendo-los-objetos-en-javascript-3a6d3a0695e5)\n",
    "path": "/en/blog/object-atribute-properties",
    "id": "en/object-atribute-properties"
  },
  {
    "title": "Explicit Conditional Rendering",
    "description": "A functional and maintainable pattern for conditionally displaying UI fragments without overusing logical or ternary operators.",
    "pubDate": "2025-07-28T00:00:00.000Z",
    "categories": [
      "design patterns"
    ],
    "tags": [
      "Astro",
      "Functional UI",
      "JSX",
      "Components",
      "patterns"
    ],
    "draft": false,
    "heroImage": "/blog-placeholder-23.jpg",
    "content": "\nIn JSX-based environments like Astro, conditionally rendering content blocks is a common task. But if you overuse ternaries or `&&`, the code ends up looking like a riddle.\n\nThis pattern proposes encapsulating visibility logic into a semantic and reusable component: `ShowWhen.astro`.\n\n## The Problem\n\n```astro\n<section>\n  {\n    currentPage === 1 && (\n      <div>\n        <h2>{t(lang, \"blogList.title\")}</h2>\n        <p>{t(lang, \"blogList.description\")}</p>\n      </div>\n    )\n  }\n</section>\n```\n\nThis pattern is **functional, but opaque.** The `&&` requires understanding precedence and structure. Writing more complex or nested logic breaks it.\n\n## The Solution:\n\nWe create a dedicated component to represent the _semantic intent_: display content if a condition is met.\n\n### `components/ShowWhen.astro`\n\n```astro\n---\nconst { when, children } = Astro.props;\n---\n\n{when && children}\n```\n\n**As simple as that.** Any JSX block can now be explicitly shown or hidden.\n\n## Usage Example\n\n```astro\n---\nimport ShowWhen from \"~/components/ShowWhen.astro\";\n---\n\n<section>\n<ShowWhen when={currentPage === 1}>\n    <div>\n        <h2>{t(lang, \"blogList.title\")}</h2>\n        <p>{t(lang, \"blogList.description\")}</p>\n      </div>\n</ShowWhen>\n</section>\n```\n\n## Advantages\n\n- ✅ **Readability**: The `when` prop conveys intent. No need to decode expressions.\n- ✅ **Reusability**: Can be extended with logging, debug traces, or entry/exit animations.\n- ✅ **Separation of concerns**: Visibility logic is abstracted away from the main markup.\n- ✅ **Works in server components and layouts**: no side effects.\n\n## Variants\n\nWe can combine this pattern with more structured alternatives:\n\n```astro\n<If condition={isLoading}>\n  <Then>\n    <Spinner />\n  </Then>\n  <Else>\n    <Content />\n  </Else>\n</If>\n```\n\nWhile this adds more complexity, it can be useful in branched flows or when reusing declarative logic across multiple places.\n\n## Conclusion\n\nIt's not just about making it work. It's about making the code communicate _what it's trying to do_.\n\nThe component encapsulates a common UI intention: **show something if a condition is met**.\n",
    "path": "/en/blog/patterns/conditional-rendering-with-show.astro",
    "id": "en/patterns/conditional-rendering-with-show.astro"
  },
  {
    "title": "IIFE",
    "description": "Understanding Immediately Invoked Function Expressions (IIFE) in JavaScript and their use in preventing global scope pollution",
    "pubDate": "2018-01-14",
    "tags": [
      "design patterns",
      "IIFE"
    ],
    "categories": [
      "design patterns"
    ],
    "draft": false,
    "heroImage": "/blog-placeholder-6.jpg",
    "content": "\n# IIFE - Iimmediatelly Invoked Function Expression\n\n```javascript\nvar foo = \"foo1\";\n\n(function () {\n  var foo = \"foo2\";\n  console.log(foo); // foo2\n})();\n\nconsole.log(foo); // foo1\n\n// we can also write the above statement like:\n(function () {\n  // code\n})();\n```\n\nWe use IIFE in order to not pollute the global scope.\n\n<div class=\"bibliography\">\nBibliography: <br/><br/>\n\n- Ben Alman: [Immediately-Invoked Function Expression (IIFE)](http://benalman.com/news/2010/11/immediately-invoked-function-expression/)\n\n</div>\n",
    "path": "/en/blog/patterns/iife",
    "id": "en/patterns/iife"
  },
  {
    "title": "Mixins",
    "description": "Understanding mixins in JavaScript as a solution for multi-inheritance, including delegation, concatenative, and functional inheritance patterns",
    "pubDate": "2018-11-18",
    "tags": [
      "design patterns",
      "mixins",
      "functional mixins",
      "inherence"
    ],
    "categories": [
      "design patterns"
    ],
    "draft": false,
    "heroImage": "/blog-placeholder-7.jpg",
    "content": "\nIn JavaScript we can only inherit from a single object. There can be only one **[[Prototype]]** for\nan object.\nAnd a class may extend only one other class.\n\n**To solve the use of multi inheritance we use mixins**.\n\nIn object-oriented programming languages, a Mixin is a class that contains methods for use by\nother classes without having to be the parent class of those other classes.\n\nA mixin can also be viewed as an **interface with implemented methods**.\nThis pattern is an example of enforcing the [**dependency inversion principle**](https://en.wikipedia.org/wiki/Dependency_inversion_principle).\n\n## Inheriting \"methods\"\n\nJavaScript does not have methods in the form that class-based languages define them.\n**In JavaScript, any function can be added to an object in the form of a property**.\nAn inherited function acts just as any other property, including property shadowing\n\nThere is more than one type of prototypal inheritance:\n\n- **Delegation** (i.e., the prototype chain).\n- **Concatenative** (i.e. mixins, `Object.assign()`).\n- **Functional** (Not to be confused with functional programming. A function used to create a\n  closure for private state/encapsulation).\n\nEach type of prototypal inheritance has its own set of use-cases, but all of them are equally\nuseful in their ability to enable composition, which creates **has-a** or **uses-a** or **can-do**\nrelationships as opposed to the is-a relationship created with class inheritance.\n\n## Delegation\n\nWe can work with delegation by using apply, bind or call to inherit from another object. Let's\nsee an example: <br>\n\n```javascript\nfunction Product(name, price) {\n  this.name = name;\n  this.price = price;\n}\n\nfunction Food(name, price) {\n  Product.call(this, name, price);\n  this.category = \"food\";\n}\n\nfunction Toy(name, price) {\n  Product.call(this, name, price);\n  this.category = \"toy\";\n}\n\nvar cheese = new Food(\"feta\", 5);\nvar fun = new Toy(\"robot\", 40);\n```\n\n<a href=\"../testing-protoype-inheritance/\" target=\"_self\">This is another \"tricky\"\nexample </a>\n\n## Concatenative\n\n**Using Object.assign() as mixin**\n\n```javascript\n// mixin\nlet sayHiMixin = {\n  sayHi() {\n    alert(`Hello ${this.name}`);\n  },\n  sayBye() {\n    alert(`Bye ${this.name}`);\n  },\n};\n\n// usage:\nconst User = function (name) {\n  this.name = name;\n};\n\n// copy the methods\nObject.assign(User.prototype, sayHiMixin);\n// now User can say hi\nnew User(\"Dude\").sayHi(); // Hello Dude!\n```\n\n**or if you were using classes you could do something like this:**\n\n```javascript\nclass User extends Person {\n  // ...\n}\n\nObject.assign(User.prototype, sayHiMixin);\n```\n\n###Functional Mixins\n\nIf the functions defined by mixins are intended solely for the use of other objects,\nwhy bother creating mixins as regular objects at all? Put another way, a **mixin should be a\nprocess not an object**.\n\nThe logical conclusion is to make our mixins into functions into which consumer objects inject\nthemselves by delegation, thus cutting out the middle guy (the extend function) entirely.\n\n```javascript\nvar asCircle = function () {\n  this.area = function () {\n    return Math.PI * this.radius * this.radius;\n  };\n  this.grow = function () {\n    this.radius++;\n  };\n  this.shrink = function () {\n    this.radius--;\n  };\n  return this;\n};\n\nvar Circle = function (radius) {\n  this.radius = radius;\n};\n\nasCircle.call(Circle.prototype);\n\nvar circle1 = new Circle(5);\ncircle1.area(); //78.54\n```\n\n**Mixins as verbs instead of nouns**\n\n### Adding Options\n\nThis functional strategy also allows the borrowed behaviours to be parameterized by means of\nan options argument.\n\n```javascript\nvar asOval = function ({ growBy, shrinkBy }) {\n  this.area = function () {\n    /* ... */\n  };\n  this.ratio = function () {\n    /* ...*/\n  };\n  this.grow = function () {\n    this.shortRadius += growBy / this.ratio();\n    this.longRadius += growBy;\n  };\n  // ...\n  return this;\n};\n\nvar OvalButton = function (/*...*/) {\n  //...\n};\n// ...\nasOval.call(OvalButton.prototype, { growBy: 2, shrinkBy: 2 });\n```\n\n**Further reading [Traits](https://github.com/traitsjs/traits.js)**\n\n<div class=\"bibliography\">\nBibliography: <br>\n[Angus Croll](https://javascriptweblog.wordpress.com/2011/05/31/a-fresh-look-at-javascript-mixins/?blogsub=confirming%23subscribe-blog]) <br/>\n[javascript.info](https://javascript.info/mixins)<br/>\n[Wikipedia](https://en.wikipedia.org/wiki/Mixin)<br/>\n[Eric Elliott](https://medium.com/javascript-scene/10-interview-questions-every-javascript-developer-should-know-6fa6bdf5ad95)<br/>\n[developer.mozilla](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain)<br/>\n</div>\n",
    "path": "/en/blog/patterns/mixins",
    "id": "en/patterns/mixins"
  },
  {
    "title": "testing prototype inheritance",
    "description": "Exploring prototype inheritance in JavaScript using the call method to inherit properties and methods between objects and functions",
    "pubDate": "2018-11-21",
    "tags": [
      "design patterns",
      "prototype",
      "inheritance"
    ],
    "categories": [
      "design patterns"
    ],
    "draft": false,
    "heroImage": "/blog-placeholder-17.jpg",
    "content": "\nhttps://stackoverflow.com/questions/53406070/using-call-to-inherit-objects-from-a-function\n\n```js\n// testing Call to inherit objects / functions\n// -------------------------------------------\n\n// we declare our first function\nconst funcA = function (firstName) {\n  this.firstName = firstName;\n  this.getFirstName = function () {\n    return \"My name is \" + this.firstName;\n  };\n  return this;\n};\n// Create an object out of that function\nconst objA = new funcA(\"Rodrigo\");\n\n// declare second function\nconst funcB = function (lastName) {\n  this.lastName = lastName;\n  this.getLastName = function () {\n    return \"My last name is \" + this.lastName;\n  };\n  return this;\n};\n\n// Create an Object from funcB and ObjectA\nconst objC = funcB.call(objA, \"Erades\");\n// We get an object\nconsole.log(\"TYPE OF: \", typeof objC);\nconsole.log(\"raw:\", objC);\nconsole.log(\"method A: \", objC.getFirstName());\nconsole.log(\"prop A: \", objC.firstName);\nconsole.log(\"method B: \", objC.getLastName());\nconsole.log(\"prop B: \", objC.lastName);\nconsole.log(\"------------\");\n\n// if we don't want to create an object out of a function and an object,\n// we could also inherit two functions, but the result really surprise me\nconst funcC = funcB.call(funcA, \"Alonso\");\n// We get a function !!!!!\nconsole.log(\"TYPE OF: \", typeof funcC);\nconsole.log(\"raw:\", funcC);\n// To get result we need to do this:\nconsole.log(\"method ==>: \", funcC(\"Rui\"));\nconsole.log(\"method A: \", funcC(\"Rui\").getFirstName());\nconsole.log(\"prop A: \", funcC(\"Maria\").firstName);\nconsole.log(\"method B: \", funcC.getLastName());\nconsole.log(\"prop B: \", funcC.lastName);\nconsole.log(\"------------\");\n```\n",
    "path": "/en/blog/patterns/testing-protoype-inheritance",
    "id": "en/patterns/testing-protoype-inheritance"
  },
  {
    "title": "statement branching Vs micro-branching",
    "description": "Comparing traditional statement branching with micro-branching techniques in JavaScript for more maintainable and functional code",
    "pubDate": "2018-06-06",
    "tags": [
      "statement brnaching",
      "micro-branching strategies"
    ],
    "categories": [
      "javascript",
      "functional"
    ],
    "draft": false,
    "heroImage": "/blog-placeholder-25.png",
    "content": "\n## statement branching\n\nAny construct that alters the sequence of statement execution within the global or functional scope. <br>\nThese include:<br>\n\n```js\nif\nelse\nswitch\nfor\nwhile\n```\n\nStatements are designed to execute non-linearly. Aside from the obvious bloating effect, statement branching tends to become unintuitive as it progresses.\n\n## micro-branching\n\nConditional logic contained within a statement that has no effect on the statement execution seqeunce.<br>\nThe following operators facilitate micro-branching: <br>\n\n```js\nternary (<cond> ? a : b)\n&&\n||\n```\n\nThe logic flows sequentially from top to bottom and even from left to right. There are no forks in the road. There is only one return statement and its at the bottom where we expect it. Best of all it's short. Nothing is wasted. In fact it's terse enough to be barely procedural at all.\n\nAlternatives to statement branching fall into two broad categories: **micro-branching** and **no branching at all**\n\n## Micro-branching strategies\n\n### Guards (&&) and Defaults(||)\n\n```javascript\n//invoke callback if there is one\ncallback && callback();\n//delay by argument or 20\ndelayBy(delay || 20);\n//remove node from its parent\nnode && node.parent && node.parent.removeChild(node);\n//log a test in the console id we have one\nwindow.console && console.log(\"test\");\n```\n\n<br>\n\n<blockquote> Some things just have a natural place. Birds in the sky, fish in the sea and a return statement at the end of a function.</blockquote>\n\n<br>\n\n<div class=\"bibliography\">\n\n## Bibliografía:\n\nhttps://javascriptweblog.wordpress.com/2010/07/26/no-more-ifs-alternatives-to-statement-branching-in-javascript/\n\n</div>\n",
    "path": "/en/blog/statement-branching-vs-micro-branching",
    "id": "en/statement-branching-vs-micro-branching"
  },
  {
    "title": "WPO: Web Performance Optimization",
    "description": "Exploring web optimization improvement with AI using core web vitals",
    "pubDate": "2025-08-26T00:00:00.000Z",
    "tags": [
      "javascript",
      "wpo",
      "google-core-web-vitals"
    ],
    "categories": [
      "javascript",
      "best-practices",
      "core-web-vitals",
      "wpo"
    ],
    "draft": true,
    "heroImage": "/blog-placeholder-14.jpg",
    "content": "\n## Initial Exploration\n\nAfter creating this web app [erades.com](https://erades.com), I'm going to focus on Google's core web vitals.\n\nFor this task, I will concentrate on Lighthouse.\n\nThe initial results are these:\n\n### 2025-08-12\n\n#### Desktop\n\n- [Home](../../../../assets/lighthouse/2025-08-12-HOME.html)\n- [Post](../../../../assets/lighthouse/2025-08-12-POST.html)\n- [Search](../../../../assets/lighthouse/2025-08-12-SEARCH.html)\n- [Tags](../../../../assets/lighthouse/2025-08-12-TAGS.html)\n- [Blog](../../../../assets/lighthouse/2025-08-12-BLOG.html)\n\n#### Mobile\n\n- [Home](../../../../assets/lighthouse/2025-08-12-HOME-mobile.html)\n- [Post](../../../../assets/lighthouse/2025-08-12-POST-mobile.html)\n- [Search](../../../../assets/lighthouse/2025-08-12-SEARCH-mobile.html)\n- [Tags](../../../../assets/lighthouse/2025-08-12-TAGS-mobile.html)\n- [Blog](../../../../assets/lighthouse/2025-08-12-BLOG-mobile.html)\n\n## Initial thoughts\n\nThe data yields good results due in part to the used technology stack (Server-side rendering and static site generation) and the selected meta-framework Astro.\n\nBut to achieve acceptable data, the developer has to be an expert and have fought a lot on frontend battles to understand the best practices.\n\nStill, things always escape, and there should be a way to control the core web vitals from the beginning to keep improving the numbers.\n\nOn the other hand, to achieve this, we would have to include these checks programmatically.\n\nToday, unit tests and e2e or functional tests are already part of developers' DNA. However, I see that automatic visual regression tests and performance tests do not quite catch on developers. Partly, I believe it is due to the increased time to run the pipelines.\n\nHowever, I consider that the automatic visual regression tests are essential. In fact, if I had to choose between unit or component tests and visual regression tests, I would opt for regression ones.\n\nIn the case of the tests for WPO, I think developers do not realize the value these tests represent for the business. They think more about the work that these tests entail than about the benefit.\n\n## Work Approach\n\n- To be able to extract statistics programmatically, I'm going to find a way to implement Lighthouse or similar tools.\n\n### Attack Plan (synthesis)\n\n1. Automated lab metrics (synthetic): Local and CI Lighthouse CI, with performance budgets and assertions that break the build when you go over. HTML/JSON reports stored as artifacts and/or on a LHCI server.\n2. Field Metrics (RUM): real LCP/INP/CLS in production via web-vitals, sent to your backend/GA4. This keeps you from optimizing blindly.\n3. Public benchmarks: PSI/CrUX in CI to see how Google measures you (Lighthouse + aggregated real data).\n4. Optional power-up: sitespeed.io to track multiple URLs, record videos/filmstrips, and more precise budgets; upload results to S3/GCS.\n\n### Lighthouse\n\nInstalled Lighthouse\n\nQuick alternative to run:\n\n```bash\nnpx unlighthouse --site https://erades.com\n```\n\nThis gives you the metrics of the entire site.\n",
    "path": "/en/blog/wpo/wpo",
    "id": "en/wpo/wpo"
  },
  {
    "title": "Metodologías: Cómo preguntar a la IA",
    "description": "Guía práctica para redactar prompts efectivos usando la metodología ASPECCT, con plantilla, ejemplo real y comparación con marcos alternativos.",
    "pubDate": "2025-08-10T00:00:00.000Z",
    "tags": [
      "ASPECCT",
      "prompt-engineering",
      "best-practices",
      "artificial-intelligence"
    ],
    "categories": [
      "AI",
      "Crafting"
    ],
    "draft": false,
    "heroImage": "/blog-placeholder-21.jpg",
    "content": "\nLa calidad de las respuestas de un modelo depende en gran medida de la calidad del prompt. **ASPECCT** es una forma simple y potente de estructurar lo que pides para obtener resultados consistentes.\n\n## Qué es ASPECCT\n\n- **A — Audiencia**: define para quién es la salida.\n- **S — Style (Estilo)**: tono y registro (técnico, mentor, formal…).\n- **P — Purpose (Propósito)**: objetivo claro de la tarea.\n- **E — Examples (Ejemplos)**: entradas/salidas de referencia.\n- **C — Constraints (Restricciones)**: límites de palabras, formato, prohibiciones.\n- **Cxt — Context (Contexto)**: lo que el modelo debe saber del dominio/situación.\n- **T — Type of Output (Tipo de salida)**: formato esperado (lista, tabla, JSON, Markdown).\n\n## Para muestra un botón\n\nPrompt Final:\n\n> \" Escribe una lista breve (T) que explique los beneficios de serverless (P) para CTOs de startups (A) usando un tono conciso y técnico (S). Debe tener menos de 80 palabras y usar viñetas (C). Contexto: estamos preparando documentación interna para desarrolladores sin experiencia con AWS (Cxt).\"\n\n## ¿Es buena la metodología ASPECCT?\n\nASPECCT encapsula principios de prompting ampliamente recomendados por la industria: **dar instrucciones claras y específicas, aportar contexto, mostrar ejemplos y fijar un formato de salida**.\n\nEstas prácticas están alineadas con las guías oficiales de las compañías que se dedican a general modelos:\n\n- **OpenAI:** guías de prompting y mejores prácticas (instrucciones claras, descomponer tareas, dar ejemplos y formato de salida).\n- **Anthropic:** estrategias de prompting (rol/persona, restricciones, contexto, formato y razonamiento paso a paso cuando conviene).\n- **Google (Gemini):** diseño de prompts con objetivos, contexto, ejemplos y formato de respuesta.\n\nNo hay evidencias independientes de que un único marco supere a los demás en todos los casos; **ASPECCT es sólido** porque cubre los elementos que más influyen en la calidad de la respuesta, y es fácil de aplicar de forma consistente.\n\n## Otras alternativas\n\nComo en todo y en especial cunado estmoas al principio de estas nueva era existen otras alternativas también muy válidas.\n\n- **CO-STAR** (Context, Objective, Style, Tone, Audience, Response): equivalente funcionalmente a ASPECCT con énfasis explícito en tono y en la forma de respuesta. Útil cuando el **branding/voz** es crucial.\n\n- **CRISPE**: variantes populares ponen foco en restricciones, rol/persona, entradas de usuario, pasos y ejemplos. Útil para **tareas operativas repetibles con checklist estricto**.\n\n- **Buenas prácticas de proveedor** (OpenAI, Anthropic, Google): combinan los mismos principios con recomendaciones tácticas (p. ej., dividir problemas, usar ejemplos, pedir formato estructurado).\n\n- En problemas de razonamiento, es recomendable añadir técnicas como “razonamiento paso a paso” o “descomposición en subtareas”.\n\n- En outputs estructurados, especifica esquema y validación (p. ej., JSON estrictamente tipado).\n\n## Una aproximación a la creación del prompt\n\n1. Completa la checklist ASPECCT antes de escribir el prompt.\n2. Redacta un primer borrador.\n3. Pide el resultado en el formato exacto (Type of Output) y dentro de los límites (Constraints).\n4. Itera con 1–2 ejemplos (Examples) si la salida no cumple.\n5. Refuerza propósito, audiencia y estilo si notas deriva.\n\n<div class=\"bibliography\">\n\n## Bibliografía y referencias\n\n- OpenAI — Best practices for prompt engineering: [platform.openai.com/docs/guides/prompt-engineering](https://platform.openai.com/docs/guides/prompt-engineering)\n- Anthropic — Prompt engineering overview (Claude): [docs.anthropic.com/.../prompt-engineering/overview](https://docs.anthropic.com/en/docs/build-with-claude/prompt-engineering/overview)\n- Google — Writing effective prompts (Workspace/Gemini): [workspace.google.com/resources/ai/writing-effective-prompts](https://workspace.google.com/resources/ai/writing-effective-prompts)\n- Microsoft Learn — Prompt engineering (Azure OpenAI): [learn.microsoft.com/.../prompt-engineering](https://learn.microsoft.com/azure/ai-services/openai/concepts/prompt-engineering)\n- Prompt Engineering Guide (DAIR.AI): [promptingguide.ai](https://www.promptingguide.ai/)\n- Marco CO-STAR (introducción y ejemplos prácticos): [writesonic.com/blog/costar-framework](https://writesonic.com/blog/costar-framework)\n\n</div>\n",
    "path": "/es/blog/ai-take-aways/aspecct-metodologia-prompting",
    "id": "es/ai-take-aways/aspecct-metodologia-prompting"
  },
  {
    "title": "Lecciones aprendidas sobre i18n con IA",
    "description": "Reflexiones y aprendizajes sobre la internacionalización (i18n) usando la Inteligencia Artificial, retos comunes y mejores prácticas para los equipos de desarrollo del futuro.",
    "pubDate": "2024-06-15T00:00:00.000Z",
    "tags": [
      "i18n",
      "internacionalización",
      "mejores-practicas",
      "inteligencia-artificial",
      "desarrollo-web"
    ],
    "categories": [
      "AI",
      "Crafting"
    ],
    "draft": false,
    "heroImage": "/blog-placeholder-24.jpg",
    "content": "\nLa internacionalización (i18n) ha sido tradicionalmente uno de los procesos más tediosos y propensos a errores en el desarrollo web. Sin embargo, con la llegada de la Inteligencia Artificial, estamos presenciando un cambio de paradigma que está transformando completamente cómo abordamos las traducciones en nuestros proyectos.\n\n## El cambio de enfoque: de traducción incremental a traducción contextual\n\n### El método tradicional\n\nTradicionalmente, el flujo de trabajo para la internacionalización seguía un patrón incremental:\n\n1. **Desarrollo paralelo**: Construíamos las páginas mientras creábamos las traducciones simultáneamente\n2. **Fragmentación del contexto**: Cada texto se traducía de forma aislada, perdiendo el contexto visual y funcional\n3. **Inconsistencias**: Las traducciones se hacían por partes, generando inconsistencias en el tono y estilo\n4. **Revisión constante**: Necesitábamos revisar y ajustar traducciones conforme evolucionaba la interfaz\n\nEste enfoque tenía un problema fundamental: **la pérdida del contexto**. Al traducir textos de forma aislada, perdíamos la visión completa de cómo funcionaba la página en su conjunto.\n\n### El nuevo paradigma con IA\n\nCon la Inteligencia Artificial, podemos adoptar un enfoque completamente diferente:\n\n1. **Desarrollo monolingüe completo**: Construimos la página completa en un idioma (preferiblemente el idioma principal del equipo)\n2. **Contexto preservado**: La IA puede ver la página completa y entender el contexto visual, funcional y de usuario\n3. **Traducción contextual**: La IA genera traducciones que mantienen coherencia con el diseño y la funcionalidad\n4. **Iteración rápida**: Podemos ajustar y mejorar las traducciones de forma más eficiente\n\n## Ventajas del nuevo enfoque\n\n### 1. Contexto completo hasta el último momento\n\nLa mayor ventaja es que mantenemos el contexto visual y funcional hasta el momento de la traducción. En lugar de trabajar con claves como `\"button.accept\"` o `\"error.validation\"`, la IA puede ver exactamente cómo se usa cada texto en la interfaz.\n\n### 2. Mejor calidad de traducción\n\nLa IA puede generar traducciones más naturales y contextualmente apropiadas porque entiende:\n\n- El propósito de cada elemento (botón, error, etiqueta)\n- La jerarquía visual de la información\n- El flujo de interacción del usuario\n- El tono y estilo general de la aplicación\n\n### 3. Consistencia automática\n\nLa IA puede mantener consistencia en:\n\n- Terminología técnica\n- Tono de comunicación\n- Estilo de escritura\n- Convenciones de interfaz\n\n## Desafíos y consideraciones\n\n### ¿Dejar que la IA cree la jerarquía o hacerlo manualmente?\n\nEste es un punto crucial que requiere reflexión. Tradicionalmente, extraíamos patrones para crear jerarquías de traducciones:\n\n```typescript\n// Enfoque tradicional\nconst translations = {\n  buttons: {\n    accept: \"Aceptar\",\n    cancel: \"Cancelar\",\n    save: \"Guardar\",\n  },\n  errors: {\n    validation: \"Error de validación\",\n    network: \"Error de conexión\",\n  },\n};\n```\n\nCon la IA, tenemos dos opciones:\n\n#### Opción 1: IA genera la estructura\n\nDejar que la IA proponga la organización de las traducciones basándose en patrones que detecte.\n\n**Ventajas:**\n\n- Menos trabajo manual\n- Detección automática de patrones\n- Adaptación a nuevos contextos\n\n**Desventajas:**\n\n- Menos control sobre la estructura\n- Posibles inconsistencias en la organización\n- Difícil de mantener a largo plazo\n\n#### Opción 2: Estructura manual con guías para la IA\n\nDefinir patrones y estructura, pero usar la IA para generar el contenido.\n\n**Ventajas:**\n\n- Control total sobre la organización\n- Consistencia en la estructura\n- Más fácil de mantener\n\n**Desventajas:**\n\n- Requiere más trabajo inicial\n- Menos flexibilidad para cambios\n\n## Patrones recomendados para guiar a la IA\n\n### 1. Centralización de errores\n\nLos errores deben estar centralizados en un único lugar para facilitar su gestión y traducción:\n\n```typescript\n// Estructura recomendada\nconst errorMessages = {\n  validation: {\n    required: \"Este campo es obligatorio\",\n    email: \"Formato de email inválido\",\n    minLength: \"Mínimo {length} caracteres\",\n  },\n  network: {\n    timeout: \"Tiempo de espera agotado\",\n    serverError: \"Error del servidor\",\n  },\n};\n```\n\n### 2. Reutilización de elementos comunes\n\nElementos como botones, enlaces y textos de navegación deben ser reutilizables:\n\n```typescript\nconst commonElements = {\n  buttons: {\n    primary: \"Continuar\",\n    secondary: \"Cancelar\",\n    danger: \"Eliminar\",\n  },\n  navigation: {\n    back: \"Atrás\",\n    next: \"Siguiente\",\n    home: \"Inicio\",\n  },\n};\n```\n\n### 3. Patrones de interpolación\n\nDefinir patrones claros para la interpolación de variables:\n\n```typescript\nconst patterns = {\n  welcome: \"Bienvenido, {name}\",\n  itemsCount: \"{count} elementos\",\n  progress: \"{current} de {total}\",\n};\n```\n\n## Conclusiones\n\nLa IA está transformando la internacionalización de una tarea mecánica y propensa a errores a un proceso más inteligente y contextual. La clave está en encontrar el equilibrio entre automatización y control manual.\n\n**Los principios fundamentales son:**\n\n- Mantener el contexto hasta el último momento\n- Definir patrones claros para la reutilización\n- Usar la IA como herramienta, no como reemplazo\n- Iterar y mejorar continuamente el proceso\n\nEl futuro de la i18n con IA no se trata de reemplazar completamente el trabajo manual, sino de hacerlo más eficiente, contextual y de mayor calidad.\n",
    "path": "/es/blog/ai-take-aways/i18n",
    "id": "es/ai-take-aways/i18n"
  },
  {
    "title": "CSS: estrategias de carga",
    "description": "Guía práctica sobre carga de CSS: bloqueo de render, estrategias (preload, media, inline) y rendimiento web.",
    "pubDate": "2025-08-23T00:00:00.000Z",
    "tags": [
      "css",
      "performance",
      "wpo"
    ],
    "categories": [
      "css",
      "best-practices"
    ],
    "draft": false,
    "heroImage": "/blog-placeholder-26.png",
    "content": "\n## ¿Por qué es importante conocer cómo se carga el CSS?\n\nA lo mejor podemos pensar que es por el peso (muchos bites a enviar al cliente), pero la respuesta es más\nsimple, porque **bloquea el renderizado del navegador**.\n\n### **Diagrama de carga de los CSS**\n\n![css-load](/css-load.drawio.png)\n\n- **HTML Parser:**<br>\n  Es el primer paso, donde el navegador analiza el documento HTML para crear el DOM.\n- **CSS Parser:**<br>\n  Cuando el analizador de HTML encuentra hojas de estilo CSS, se las pasa al analizador de CSS.\n- **CSSOM (CSS Object Model):**<br>El analizador de CSS crea el CSSOM, una estructura en forma de árbol que representa los estilos del documento.\n- **DOM:**<br>El analizador de HTML crea esta estructura de árbol del documento HTML.\n- **Render Tree (Árbol de Renderizado):**<br>Es el renderizado a partir de la combinación del DOM y el CSSOM. Este árbol incluye solo los elementos visibles y sus estilos calculados y se aplica a la vez que las reglas de cascada.\n- **Cascade Rules (Reglas de Cascada):**<br> Aquí es donde el navegador aplica las reglas de cascada, especificidad y herencia de CSS para determinar los estilos finales de cada elemento.\n- **Final Computed Style (Estilo Calculado Final):**<br> Es el resultado final para cada elemento, mostrando todos los estilos aplicados, que se utiliza para los pasos posteriores de Layout/reflow (maquetación) y Paint (pintado).\n\n### **Maneras de cargar un CSS**\n\n#### **Externo** (`<link ...>`)\n\n<br>\n\n```html\n<head>\n  <!-- Carga bloqueante por defecto -->\n  <link rel=\"stylesheet\" href=\"/assets/styles.css\" />\n</head>\n```\n\n**Notas:**\n\n- **Bloquea el primer render** hasta parsear `styles.css`.\n- Para atenuarlo podríamos limitarlo por media por ejemplo sacando fuera los estilos de print\n\n```html\n<link rel=\"stylesheet\" href=\"/assets/print.css\" media=\"print\" />\n```\n\n#### Interno (`<style>`)\n\n<hr>\n\n```html\n<head>\n  <style>\n    :root {\n      --brand: #0a66c2;\n    }\n    body {\n      color: var(--brand);\n    }\n  </style>\n</head>\n```\n\n**Notas:**\n\n- Se parsea in situ.\n- Útil para critical CSS pequeño.\n\n#### Inline (en el atributo style)\n\n<hr>\n\n```html\n<div style=\"color: tomato; font-weight: 600\">Texto con estilo inline</div>\n```\n\n**Notas:**\n\n- Máxima precedencia (salvo `!important`).\n- No cachea\n- No reutilizable (el HTML se puede cachear pero el parseo se tiene que volver a hacer)\n\n#### Importándolo dentro de otro CSS (`@import`)\n\n<hr>\n\n```css\n/* main.css */\n@import url(\"/assets/base.css\");\n@import url(\"/assets/theme.css\") screen and (min-width: 48rem);\n\n.container {\n  margin-inline: auto;\n}\n```\n\nO desde `<style>`:\n\n```html\n<style>\n  @import url(\"/assets/base.css\");\n  body {\n    font-family: system-ui;\n  }\n</style>\n```\n\n**Notas:**\n\n- Evalúa en orden de aparición.\n- Penaliza rendimiento\n  - **Request en cadena**\n  - Genera nuevas peticiones a servidores.\n- **Problemas serios de seguridad**, te pueden robar los user/psw con un simple CSS\n- Si después de esto lo quieres seguir usando supongo que será porque te gusta el riesgo. Yo tenía una frase de joven para cuando hacía locuras\n  > Commander Salamander: Too fast to live, too young to die\"\n\n#### Dinámico por JS (inyectando `<link>` o `<style>`)\n\n<hr>\n\n```html\n<!-- **Insertar link dinámico (lazy styles)** -->\n<script>\n  const link = document.createElement(\"link\");\n  link.rel = \"stylesheet\";\n  link.href = \"/assets/chunk-above-the-fold.css\";\n  document.head.appendChild(link);\n</script>\n```\n\n```html\n<!-- **Insertar style con reglas (generadas o feature‑flag)** -->\n<script>\n  const style = document.createElement(\"style\");\n  style.textContent = `\n    .promo { display: grid; gap: 0.5rem; }\n    @media (prefers-color-scheme: dark) {\n      .promo { color: white; }\n    }\n  `;\n  document.head.appendChild(style);\n</script>\n```\n\n**Notas:**\n\n- Se aplican al terminar de parsear/adjuntar.\n- Útil para code‑splitting de estilos o tematizado runtime.\n\n### En resumen\n\nSi atendemos a los bloqueos, diferenciando **bloqueo de red** (latencia/descarga) y **bloqueo de parseo/render** (el parser se para mientras procesa reglas), tendríamos algo así:\n\n| Forma de carga              | Bloqueo de red | Bloqueo de parseo/render | Notas                                                                 |\n| --------------------------- | -------------- | ------------------------ | --------------------------------------------------------------------- |\n| **Hoja externa (link)**     | ✅ Sí          | ✅ Sí (hasta integrar)   | Espera a descargar → parsear → integrar en CSSOM. Bloquea FCP/LCP.    |\n| **Interno (style)**         | ❌ No          | ✅ Sí (mínimo)           | Se parsea inline en el HTML. No hay espera de red, solo CPU local.    |\n| **Inline (atributo style)** | ❌ No          | ✅ Sí (al aplicar)       | Se aplica al instante al elemento. Coste mínimo por regla puntual.    |\n| **@import en CSS**          | ✅ Sí (extra)  | ✅ Sí                    | **Peor caso:** descarga en cadena → cada import bloquea el siguiente. |\n| **Dinámico (JS)**           | ✅ Sí          | ❌ No (async)            | Se descarga al insertar el `<link>`/`<style>`. No bloquea el parser.  |\n\n**Conclusión**\n\n- Lo que realmente mata tu render son las **descargas externas síncronas** (link + import).\n- Inline e interno sólo paran el parser localmente (normalmente irrelevante salvo CSS gigante).\n- **Dinámico no bloquea el parser** porque ocurre después, pero **retrasa la aplicación de estilos** hasta que se descarga/aplica (AKA FOUC → Flash of Unstyled Content).\n\n---\n\n### Bola extra: Estrategias conocidas para minimizar el bloqueo\n\n- Critical CSS en línea para el above-the-fold.\n- `preload` del CSS principal y aplicar como stylesheet cuando cargue.\n- Defer del CSS no crítico con `media` y `onload` (el viejo truquito de javascript).\n- Dividir CSS por ruta o layout.\n\n### Preload + swap (adelantar descarga; aplicar tras `onload`)\n\n```html\n<link\n  rel=\"preload\"\n  as=\"style\"\n  href=\"/assets/late.css\"\n  onload=\"this.rel='stylesheet'\"\n/>\n<noscript><link rel=\"stylesheet\" href=\"/assets/late.css\" /></noscript>\n```\n\n**notas:**\n\n- No aplica estilos hasta el onload (evita bloquear el primer render).\n- Hay que mantener un fallback en `<noscript>` por si las moscas.\n\n### Media para cargar sin bloquear y activar luego\n\n```html\n<link\n  rel=\"stylesheet\"\n  href=\"/assets/print.css\"\n  media=\"print\"\n  onload=\"this.media='all'\"\n/>\n```\n\n- Se descarga en segundo plano\n- Se activa cuando cambias media a `all` .\n",
    "path": "/es/blog/css-load",
    "id": "es/css-load"
  },
  {
    "title": "css-load",
    "description": "Estrategias para cargar CSS de forma eficiente.",
    "pubDate": "2025-08-23T00:00:00.000Z",
    "tags": [
      "css",
      "performance",
      "wpo"
    ],
    "categories": [
      "css",
      "best-practices"
    ],
    "draft": true,
    "heroImage": "/blog-placeholder-10.jpg",
    "content": "\n## A igualdad de especificidad ¿quién gana?\n\n### Precedencia\n\n!important > inline > autor > user agent. Luego especificidad. Luego orden.\n",
    "path": "/es/blog/css-precedence",
    "id": "es/css-precedence"
  },
  {
    "title": "sistema de partículas",
    "pubDate": "2019-01-11T00:00:00.000Z",
    "description": "Explorando técnicas de animación de sistemas de partículas utilizando Canvas y JavaScript para crear efectos visuales dinámicos",
    "tags": [
      "particle system"
    ],
    "categories": [
      "experiment"
    ],
    "draft": false,
    "heroImage": "/blog-placeholder-11.jpg",
    "content": "\n<script type=\"module\" src=\"/js/experiments/system01.js\"></script>\n\n<canvas></canvas>\n",
    "path": "/es/blog/experiments/particle-system-01",
    "id": "es/experiments/particle-system-01"
  },
  {
    "title": "Notación Hindley-Milner",
    "description": "Entendiendo la notación de tipo Hindley-Milner en programación funcional para expresar firmas de funciones y relaciones de tipo",
    "pubDate": "2019-04-11",
    "tags": [
      "declarative",
      "Pure functions",
      "Inmutable",
      "currying",
      "Hindley-Milner"
    ],
    "categories": [
      "functional"
    ],
    "draft": false,
    "heroImage": "/blog-placeholder-13.jpg",
    "content": "\nUna forma de crear una notación para expresar qué tipos de parámetro toma una función y qué devuelve.\n\n## Lo básico\n\nUna función que toma un valor primario (\"tipo antiguo\" como cadena, número, booleano, matriz, función ...) y devuelve otro valor primario:\n\n`instruction :: String -> String`\n\n```javascript\nconst instruction = function (verb) {\n  return verb + \" me\";\n};\n```\n\nla función instruction toma una cadena y devuelve una cadena\n\nTambién podría hacer algo así:\n\n`length :: String → Number`\n\n```javascript\nconst length = function (s) {\n  return s.length;\n};\n```\n\nEn el caso de una matriz de números:\n\n`length :: [Number] → Number`\n\n```javascript\n    const length = function(arr){\n        retrun arr.length\n    }\n```\n\n## Trabajando con funciones\n\nEn el caso de una función, envolvemos nuestra función entre paréntesis y dentro de los paréntesis tenemos nuestro tipo de entrada y nuestro tipo de salida:\n\n`addOneToAll :: ((Number → Number),[Number]) → [Number]`\n\n```javascript\nconst addOne = function (x) {\n  return x + 1;\n};\nconst addOneToAll = (addOne, arr) => arr.map(addOne);\n```\n\nEn este caso tenemos una función llamada addOneToAll que espera como primer parámetro una función (en nuestro caso addOne) y esta función aceptará un número y devolverá un número.\nY como segundo parámetro una matriz de números y devolverá otra matriz de números.\n\n### Funciones de currying\n\nAhora, ¿qué pasa con una función que devuelve una función que devuelve otra función ....\n\nSiguiendo lo anterior, tendríamos algo como esto:\n`replace :: String -> (String -> (String -> String))`\n\n```javascript\nvar replace = curry(function (find, replacement, str) {\n  var regex = new RegExp(find, \"g\");\n  return str.replace(regex, replacement);\n});\n```\n\nEn este caso también hacemos que la función sea curry para tomar parámetros uno por uno\n\nY en la programación funcional podemos asumir que todo es curry, así que tendemos a dejar caer los corchetes y algo como esto:\n\n` replace :: String -> String -> String -> String`\n\n## Trabajando con funciones que toman múltiples parámetros como entrada (Variables arbitrarias de Hindley-Milner)\n\nMostramos el ejemplo con la función de longitud donde podríamos tener:\n`length :: [Number] → Number`\no\n`length :: string → Number`\n\nEn este caso podríamos escribir ambos con una variable arbitraria como:\n`length :: [a] → Number`\n\nOtro ejemplo común es la identidad:\n`identity :: a -> a`\n\nY un ejemplo más complejo:\n`map :: (a -> b) -> [a] -> [b]`\n\n```javascript\nconst map = curry(function (callback, array) {\n  return array.map(callback);\n});\n```\n\nLa función de mapa toma una función que toma una variable de tipo `a` y devuelve una variable de tipo `b`.\nLuego toma una **matriz de valores**, todos de tipo `a`, y devuelve una **matriz de valores**, todos de tipo `b`.\n\n---\n\n## Trabajando con Ramda\n\n## Tipos parametrizados\n\nPodemos imaginar fácilmente un tipo que representa una colección de elementos similares,\nllamémoslo una Caja. Pero ninguna instancia es una Caja arbitraria; cada uno solo puede contener un tipo de elemento.\n\n`makeBox :: Number -> Number -> Number -> [a] -> Box a`\n\n```javascript\n  const makeBox = curry((height, width, depth, items) => /* ... */);\n```\n\n## Alias de tipo\n\nSi tuviéramos un tipo parametrizado Usuario String, donde la String se supone que representa un nombre, y quisieramos ser más específicos acerca del tipo de String que se representa al generar una URL, podríamos crear un alias de tipo así:\n\n`toUrl :: User Name u => Url -> u -> Url`\n\n`Name = String`\n\n` Url = String`\n\n```javascript\nconst toUrl = curry(\n  (base, user) => base + user.name.toLowerCase().replace(/\\W/g, \"-\")\n);\ntoUrl(\"http://example.com/users/\", { name: \"Fred Flintstone\", age: 24 });\n//=> 'http://example.com/users/fred-flintstone'\n```\n\n## Restricciones de tipo [Ord]\n\nA veces queremos restringir los tipos genéricos que podemos usar en alguna firma de alguna manera u otra.\n\nPodríamos querer una función máxima que pueda operar sobre Números, en Cadenas, en Fechas, pero no en Objetos arbitrarios.\n\nQueremos describir tipos ordenados, aquellos para los cuales **a < b siempre devolverá un resultado significativo**\n\n`maximum :: Ord a => [a] -> a`\n\n```javascript\nconst maximum = (vals) =>\n  reduce((curr, next) => (next > curr ? next : curr), head(vals), tail(vals));\nmaximum([3, 1, 4, 1]); //=> 4\nmaximum([\"foo\", \"bar\", \"baz\", \"qux\", \"quux\"]); //=> 'qux'\nmaximum([\n  new Date(\"1867-07-01\"),\n  new Date(\"1810-09-16\"),\n  new Date(\"1776-07-04\"),\n]); //=> new Date(\"1867-07-01\")\n```\n\n`Ord a ⇒ [a] → a` dice que la máxima toma una colección de elementos de algún tipo, pero ese tipo debe adherirse a Ord.\n\nEn JS, no hay forma de garantizar que el usuario no nos pasará [1, 2, 'a', false, undefined, null].\nAsí que toda nuestra anotación de tipo es **descriptiva y aspiracional** en lugar de ser impuesta por el compilador, como sería en, digamos, Haskell.\n\n## Firmas múltiples\n\nA veces, en lugar de tratar de encontrar la versión más genérica de una firma, es más sencillo enumerar varias firmas relacionadas por separado.\nPodríamos hacer eso como abajo:\n\n`getIndex :: a -> [a] -> Number`\n`:: String -> String -> Number`\n\n```javascript\nconst getIndex = curry((needle, haystack) => haystack.indexOf(needle));\ngetIndex(\"ba\", \"foobar\"); //=> 3\ngetIndex(42, [7, 14, 21, 28, 35, 42, 49]); //=> 5\n```\n\n## Funciones variadicas (específicas para Ramda)\n\nEn Haskell, todas las funciones tienen una aridad fija. Pero Javsacript tiene que lidiar con funciones variadicas.\n`flip :: (a -> b -> ... -> z) -> (b -> a -> ... -> z)`\n\n```javascript\nconst flip = (fn) =>\n  function (b, a) {\n    return fn.apply(this, [a, b].concat([].slice.call(arguments, 2)));\n  };\nflip((x, y, z) => x + y + z)(\"a\", \"b\", \"c\"); //=> 'bac'\n```\n\n## Objetos simples\n\nCuando un objeto se utiliza como un diccionario de valores de tipo similar (a diferencia de su otro papel como un Registro), entonces los tipos de las claves y los valores pueden volverse relevantes.\nEntonces podríamos representarlos así:\n`keys :: {k: v} -> [k]`\n`values :: {k: v} ->  [v]`\n\n```javascript\nkeys({ a: 86, b: 75, c: 309 }); //=> ['a', 'b', 'c']\nvalues({ a: 86, b: 75, c: 309 }); //=> [86, 75, 309]\n```\n\n## Ejemplo complejo\n\n`Lens s a -> (a -> a) -> s -> s`\n`Lens s a = Functor f => (a -> f a) -> s -> f s`\n\nComenzamos con el alias de tipo, Lens s a = Functor f ⇒ (a → f a) → s → f s.\nEsto nos dice que el tipo Lens **está parametrizado por dos variables genéricas, s, y a**.\nSabemos que hay una restricción en el tipo de la variable f utilizada en una Lens: **debe ser un Functor**.\nCon eso en mente, vemos que una Lens es una función acurruada de dos parámetros, el primero siendo una función de\nun valor del tipo genérico a a uno del tipo parametrizado f a, y el segundo siendo un valor del tipo genérico s.\n\n**El resultado** es un valor del tipo parametrizado `f・s`\n\n<div class=\"bibliography\">\nBibliografía:<br><br>\n\n- [gentle introduction to functional javascript style](https://jrsinclair.com/articles/2016/gentle-introduction-to-functional-javascript-style#hindley-milnertypesignatures)\n- [function type signatures in Javascript](https://hackernoon.com/function-type-signatures-in-javascript-5c698c1e9801)\n- [Type signatures in Ramda](https://github.com/ramda/ramda/wiki/Type-Signatures)\n</div>\n",
    "path": "/es/blog/functional/hindley-milner-notation",
    "id": "es/functional/hindley-milner-notation"
  },
  {
    "title": "combinadores",
    "description": "Comprendiendo los combinadores en la programación funcional como funciones puras de orden superior para componer y controlar el flujo del programa",
    "pubDate": "2019-01-10",
    "tags": [
      "declarative",
      "Pure functions",
      "Inmutable",
      "currying",
      "combinator"
    ],
    "categories": [
      "functional"
    ],
    "draft": false,
    "heroImage": "/blog-placeholder-10.jpg",
    "content": "\nUn combinator es una función de orden superior, **funciones puras** que no tienen ninguna **variable libre** y\npueden combinar artefactos primitivos como otras funciones (u otros combinators) y comportarse como lógica de control.\n\nLas **variables libres** son simplemente variables en el contexto de una función que no se pasan explícitamente\ncomo argumento.\n\nNuestro compromiso es que todas las dependencias se pasen por parámetro.\n\nLos combinators desbloquean la libertad y facilitan la programación libre de puntos.\nDebido a que los combinators son puros, se pueden componer en otros combinators,\nproporcionando un número infinito de alternativas para expresar y reducir la complejidad de la escritura\ncualquier tipo de aplicación.\n\nPor ejemplo, una función de composición será un combinator:\n\n```javascript\nconst compose = (f, g) => (x) => f(g(x));\n\nconst addTwo = (x) => x + 2;\nconst multByThree = (x) => x * 3;\n\nconst operator = compose(addTwo, multByThree);\n\nconsole.log(operator(7)); // 23\n// NOTA: recuerda que compose se ejecutará de derecha a izquierda\n```\n\nEn Ramda hay muchos combinators que podemos usar:\n\n- compose\n- pipe\n- identity\n- tap\n- alternation\n- sequence\n- fork (join)\n\n## identity\n\nEl combinator identity es una función que devuelve el mismo valor que se le proporcionó como argumento:\n\n`identity :: (a) -> a`\n\nSe utiliza ampliamente al examinar las propiedades matemáticas de las funciones,\npero también tiene otras aplicaciones prácticas:\n\n- Proporcionar datos a funciones de orden superior que lo esperan al evaluar un argumento de función.\n- Pruebas unitarias del flujo de combinators de funciones donde necesita un resultado de función simple sobre el cual\n  hacer afirmaciones.\n- Extracción de datos de manera funcional de tipos encapsulados.\n\n## Tap\n\ntap es extremadamente útil para enlazar funciones vacías (como registrar o escribir un archivo o una página HTML)\nen su composición sin tener que crear ningún código adicional. Lo hace pasándose a sí mismo\nen una función y retornándose a sí mismo. Aquí está la firma de la función:\n\n`tap :: (a -> *) -> a -> a`\n\n## Alternation [OR - combinator]\n\nEl combinator alt permite realizar **lógica condicional simple** al proporcionar comportamiento predeterminado\nen respuesta a una llamada de función.\nEste combinator toma dos funciones y devuelve el resultado de la primera si el valor está\ndefinido (no falso, nulo o indefinido); de lo contrario, devuelve el resultado de la segunda función.\n\n## Sequence (S-combinator)\n\nEl combinator seq se utiliza para recorrer una secuencia de funciones. Toma dos o más funciones\ncomo parámetros y devuelve una nueva función, que ejecuta todas ellas en secuencia contra el mismo valor.\n\nEl combinator seq no devuelve un valor; solo realiza un conjunto de acciones una tras otra.\n\n## Fork (join) combinator\n\nEl combinator fork es útil en casos donde necesitas procesar un solo recurso de dos\nmaneras diferentes y luego combinar los resultados.\n\n<br><br>\n\n<div class=\"bibliography\">\nBibliografía:<br>\n\n- Programación Funcional en JavaScript . Ed: MANNING SHELTER ISLAND. Autor: Luis Atencio.<br>\n- [Guía Más Que Adecuada para la programación funcional](https://drboolean.gitbooks.io/mostly-adequate-guide-old/content/).\n  Professor Frisby's<br>\n- [Creando una aplicación declarativa usando JavaScript funcional](https://www.packtpub.com/web-development/building-declarative-apps-using-functional-javascript-video).\n  Michael Rosata\n  </div>\n",
    "path": "/es/blog/functional/combinators",
    "id": "es/functional/combinators"
  },
  {
    "title": "programación funcional",
    "description": "Una introducción a los conceptos de programación funcional incluyendo programación declarativa, funciones puras, inmutabilidad y currificaci 3n.",
    "pubDate": "2018-01-12",
    "tags": [
      "declarative",
      "Pure functions",
      "Inmutable",
      "currying"
    ],
    "categories": [
      "functional"
    ],
    "draft": false,
    "heroImage": "/blog-placeholder-12.jpg",
    "content": "\nEn ciencias de la computación, la programación funcional es un paradigma de programación, es decir, un estilo para construir la estructura y los elementos de los programas informáticos, que considera la computación como la **evaluación de funciones matemáticas y evita el cambio de estado y los datos mutables**.\n\nEs un paradigma de programación **declarativo**, lo que significa que se programa mediante expresiones o declaraciones en lugar de sentencias. Para describirlo de manera diferente, podríamos decir que la programación **declarativa se preocupa por qué** se realiza una acción y la imperativa se preocupa por cómo realizar esa acción.\n\n## Declarativo Vs. Imperativo || Qué Vs. Cómo\n\nEn el código funcional, el valor de salida de una función depende únicamente de los argumentos que se pasan a la función, por lo que llamar a una función f dos veces con el mismo valor para un argumento x produce el mismo resultado f(x) en cada ocasión; esto contrasta con los procedimientos que dependen de un estado local o global, que pueden producir resultados diferentes en momentos diferentes cuando se llaman con los mismos argumentos pero con un estado de programa diferente. Eliminar los efectos secundarios, es decir, los cambios en el estado que no dependen de las entradas de la función, puede facilitar mucho la comprensión y la predicción del comportamiento de un programa, que es uno de los principales motivos para el desarrollo de la programación funcional.\n\nEn contraste, la programación imperativa cambia el estado con comandos en el código fuente, siendo el ejemplo más simple la asignación. La programación imperativa tiene funciones, no en el sentido matemático, sino en el sentido de subrutinas. Pueden tener efectos secundarios que pueden cambiar el valor del estado del programa. Por lo tanto, tiene sentido que existan funciones que no devuelven valores. Por esto, carecen de transparencia referencial, es decir, la misma expresión en un lenguaje puede tener valores diferentes en momentos diferentes, dependiendo del estado del programa que se ejecute.\n\n**IMPERATIVO**\n\n```javascript\nfor (var i = 0; i < users.length; i++) {\n  users[i].lastModified = new Date();\n}\n```\n\n**DECLARATIVO**\n\n```javascript\nusers.map((u) => {\n  u.lastModified = new Date();\n  return u;\n});\n```\n\n## Funciones matemáticas (Funciones puras)\n\nSon funciones que siempre devuelven el mismo resultado con la misma entrada. No dependen de ningún otro dato más allá de lo que se les pasa a la función y no alteran ningún dato más allá de lo que devuelven.\n\n## Datos mutables\n\nLos datos mutables son datos que pueden cambiar.\nUn ejemplo sería ordenar un array. Si tenemos un array desordenado y creamos una función que ordena ese array, si la función devuelve un nuevo array con el orden, estos serían datos inmutables porque no cambiamos el array original. Sin embargo, si la función toma nuestro array inicial y lo modifica, entonces los datos son mutables y perderemos la referencia original del array y podríamos tener efectos secundarios.\n\n## Trabajando con funciones de array\n\n```javascript\n// Devuelve el valor del primer elemento en un array que pasa una prueba\nusers.find((u) => {\n  return u.id === id;\n});\n// Comprueba si todos los elementos en un array pasan una prueba\nusers.every((u) => {\n  return u.isAdmin;\n});\n// Comprueba si alguno de los elementos en un array pasa una prueba\nusers.some((u) => {\n  return u.isAdmin;\n});\n// Crea un nuevo array con cada elemento en un array que pasa una prueba\nusers.filter((u) => {\n  return u.isAdmin;\n});\n// Crea un nuevo array con el resultado de llamar a una función para cada elemento del array\nusers.map((u) => {\n  u.updated = new Date();\n  return u;\n});\n// Reduce los valores de un array a un solo valor (de izquierda a derecha)\nusers.reduce((accumulator, n) => {\n  return accumulator + n;\n}, 0);\n```\n\n## Encadenamiento\n\nEjercicio: Para un array dado de números queremos:\n\n1.  Reducir cada valor en 1.\n2.  Sumar todos los valores resultantes que sean divisibles por 3.\n\nSolución:\n\n**IMPERATIVO**\n\n```javascript\n// Array dado\nlet numbers = [2, 4, 10, 12, 19, 23];\nlet sum = 0;\n\nfor (let i = 0; i < numbers.length; i++) {\n  numbers[i] = numbers[i] - 1;\n  if (numbers[i] % 3 == 0) {\n    sum += numbers[i];\n  }\n}\n\nconsole.log(sum); // sum = 30;\n```\n\n**DECLARATIVO**\n\n```javascript\n// Array dado\nlet numbers = [2, 4, 10, 12, 19, 23];\n\nlet substractOne = (n) => n - 1;\nlet isDivisbleBy3 = (n) => (n % 3 === 0 ? n : null);\nlet add = (n, i) => n + i;\n\nlet sum = numbers.map(substractOne).filter(isDivisbleBy3).reduce(add, 0);\n\nconsole.log(sum); // sum = 30;\n```\n\n## Currying\n\nConvertir una función que acepta varios parámetros en una serie de funciones que solo aceptan un parámetro cada una.\n\nVeamos un ejemplo: <br>\n\n```javascript\n  // Empezando desde\n  users.find((u) => {\n    return u.id === id;\n  });\n\n// Ahora podríamos hacer algo así:\n\nconst byId = (item) => {\n  return item.id === id;\n}\n\nusers.find(byId)\n\n// El problema con el código anterior es que id será indefinido ya que necesitamos 2 parámetros y solo estamos pasando uno\n\n// La solución sería una función que retorna otra función\nconst byId = (id) => {\n  return (item) => {\n    return item.id === id;\n  }\n}\n\nusers.find(byId(2))\n\n// Entonces esto también significa que podrías usar byId en cualquier lugar y puedes llamarlo así:\nbyId(2)(users)\n\n// Ramda tiene una función curry que hace currying\n\nconst byId = R.curry(id, item) {\n  return item.id === id;\n}\n\nusers.find(byId(2))\n\n// También la ventaja de usar la función R.curry es que acepta más de 2 parámetros\n// Por ejemplo:\n\nconst add = R.curry((a,b,c,) => {\n  return a + b + c;\n})\n\nadd(1)(2)(3);\n\n\n```\n\nEste es otro ejemplo\n\n```javascript\nconst convertUnits =\n  (toUnit, factor, offset = 0) =>\n  (input) =>\n    ((offset + input) * factor).toFixed(2).concat(toUnit);\n\nconst milesToKm = convertUnits(\"km\", 1.60936, 0);\nconst poundsToKg = convertUnits(\"kg\", 0.4546, 0);\nconst farenheitToCelsius = convertUnits(\"grados C\", 0.5556, -32);\n\nmilesToKm(10); //\"16.09 km\"\npoundsToKg(2.5); //\"1.14 kg\"\nfarenheitToCelsius(98); //\"36.67 grados C\"\n\nconst weightsInPounds = [5, 15.4, 9.8, 110];\n\n// Sin currying\n// const weightsInKg = weightsInPounds.map(x => convertUnits('kg', 0.45460, 0)(x));\n\n// Con currying\nconst weightsInKg = weightsInPounds.map(poundsToKg);\n// \"2.27kg\", \"7.00kg\", \"4.46kg\", \"50.01kg\"\n```\n\n## Aplicación parcial\n\nSuministro de menos argumentos que los requeridos\n\n<div class=\"bibliography\">\nBibliografía:\n\n- Wikipedia: https://en.wikipedia.org/wiki/Functional_programming <br>\n- Video de Pluralsite: [(Fundamentos de la Programación Funcional en JavaScript por Nate Taylor)](https://app.pluralsight.com/library/courses/javascript-functional-programming-fundamentals/exercise-files)<br>\n- w3School: [Referencia del Array en JavaScript](https://www.w3schools.com/jsref/jsref_obj_array.asp)\n</div>\n",
    "path": "/es/blog/functional/functional-programming",
    "id": "es/functional/functional-programming"
  },
  {
    "title": "programando funtores",
    "description": "Entendiendo los funtores como un patrón de diseño para manipular de manera segura los valores envueltos en la programación funcional",
    "pubDate": "2019-01-01",
    "tags": [
      "declarative",
      "Pure functions",
      "Inmutable",
      "currying"
    ],
    "categories": [
      "functional"
    ],
    "draft": false,
    "heroImage": "/blog-placeholder-15.jpg",
    "content": "\n> **Un functor es simplemente una interfaz con un contrato.**<br>\n> Podríamos haberlo nombrado Mappable igual de fácil, pero, ¿dónde estaría la diversión en eso?.<br> > _Professor Frisby's_\n\nUn functor no es más que una estructura de datos con la que puedes mapear funciones con el propósito de\nlevantar valores en un wrapper, modificarlos, y luego devolverlos a un wrapper.\n\nEs un patrón de diseño que define la semántica de cómo debería funcionar **fmap**\n\n` fmap :: (A -> B) -> Wrapper(A) -> Wrapper(B)`\n\nVeamos un ejemplo:\n\n```javascript\n// NOTA: no podemos usar la función de flecha si estamos haciendo referencia a this dentro de la función (no \"new\" para las funciones de flecha)\nvar Contenedor = function (x) {\n  this.__valor = x;\n};\n\nContenedor.of = function (x) {\n  return new Contenedor(x);\n};\n\nContenedor.of(3); // => Contenedor(3) === { \"__valor\": 3 }\nContenedor.of(Contenedor.of(\"pepinillos\")); // => Contenedor(Contenedor(\"pepinillos\")) === { \"__valor\": { \"__valor\": \"pepinillos\" } }\n```\n\n- `Contenedor` es un objeto con una propiedad.\n\n- Muchos contenedores simplemente contienen una cosa, aunque no están limitados a una.\n  Hemos nombrado arbitrariamente a su propiedad `__valor`.\n\n- El `__valor` no puede ser de un tipo específico o nuestro `contenedor` apenas viviría hasta el nombre.\n\n- Una vez que los datos entran en el `Contenedor` ahí se quedan. Podríamos sacarlo usando `.__valor` , pero eso derrotaría al propósito.\n\n---\n\nAsí que ahora repasemos de nuevo la idea de un functor. ¿Qué es un functor y qué debería tener un functor?\n\nUn functor será principalmente un contenedor, y ¿por qué queremos hacer eso? Bueno, contener (o envolver) valores es un patrón de diseño fundamental en la programación funcional\nporque **protege el acceso directo a los valores** para que puedan ser manipulados de manera segura e inmutable en tus programas.\n\n```javascript\nclass Envoltorio {\n  constructor(valor) {\n    this._valor = valor;\n  }\n\n  toString() {\n    return \"Envoltorio (\" + this._valor + \")\";\n  }\n}\n\n// wrap :: A -> Envoltorio(A)\nconst wrap = (val) => new Envoltorio(val);\nwrap(\"Hola Muzzy\").toString(); // -> Envoltorio (Hola Muzzy)\n```\n\nAhora que tenemos un contenedor para nuestros valores necesitamos algo para operar esos valores , porque acceder a un valor envuelto sólo puede hacerse **mapeando una operación a su contenedor**.\n\nAsí que un functor debe ser un objeto envuelto y una función para **mapear** sobre los valores, en el mundo funcional suelen llamar a esta función **map** o **fmap**\n\n```javascript\nclass Envoltorio {\n  constructor(valor) {\n    this._valor = valor;\n  }\n  toString() {\n    return \"Envoltorio (\" + this._valor + \")\";\n  }\n\n  // map :: (A -> B) -> A -> B\n  map(fn) {\n    return fn(this._valor);\n  }\n}\n// wrap :: A -> Envoltorio(A)\nconst wrap = (val) => new Envoltorio(val);\nwrap(\"Hola Muzzy\").toString(); // -> Envoltorio (Hola Muzzy)\nwrap(\"Hola Muzzy\").map((item) => item.toUpperCase()); // --> HOLA MUZZY\n```\n\nEn el ejemplo anterior estamos mapeando sobre el valor pero el problema es que estamos devolviendo el valor transformado ya , lo cual está bien pero no podemos encadenar nada más dentro de este contenedor\ny perdemos la habilidad de encasillar nuestros datos porque salimos de nuestro \"contenedor seguro\".\n\nAsí que tal vez una buena idea sería devolver el resultado mapeado en un nuevo envoltorio en lugar de devolver solo el resultado. Así que cambiamos nuestra función map en un **fmap**\n\n```javascript\nclass Envoltorio {\n  constructor(valor) {\n    this._valor = valor;\n  }\n  toString() {\n    return \"Envoltorio (\" + this._valor + \")\";\n  }\n\n  // fmap :: (A -> B) -> Envoltorio[A] -> Envoltorio[B]\n  fmap(fn) {\n    return new Envoltorio(fn(this._valor));\n  }\n}\n// wrap :: A -> Envoltorio(A)\nconst wrap = (val) => new Envoltorio(val);\nwrap(\"Hola Muzzy\").toString(); // -> Envoltorio (Hola Muzzy)\nwrap(\"Hola Muzzy\").fmap((item) => item.toUpperCase()); // --> Envoltorio { _valor: 'HOLA MUZZY' }\n```\n\nAsí que ahora estamos devolviendo un nuevo objeto Envoltorio con el valor transformado después de aplicar la función mapeada (toUpperCase).\n\nfmap sabe cómo aplicar funciones a valores envueltos en un contexto. Primero abre el contenedor,\nluego aplica la función dada a su valor, y finalmente cierra el valor de nuevo en un nuevo contenedor del **mismo tipo**.\n\nEsto nos permite encadenar más acciones dentro de nuestro valor envuelto.\n\nAsí que imagina que queremos pasar a mayúsculas y luego dividir las palabras en un arreglo, podríamos hacerlo fácilmente:\n\n```javascript\nclass Envoltorio {\n  constructor(valor) {\n    this._valor = valor;\n  }\n  toString() {\n    return \"Envoltorio (\" + this._valor + \")\";\n  }\n\n  // fmap :: (A -> B) -> Envoltorio[A] -> Envoltorio[B]\n  fmap(fn) {\n    return new Envoltorio(fn(this._valor));\n  }\n}\n// wrap :: A -> Envoltorio(A)\nconst wrap = (val) => new Envoltorio(val);\n\nwrap(\"Hola Muzzy\")\n  .fmap((item) => item.toUpperCase())\n  .fmap((item) => item.split(\" \")); // -->  Envoltorio { _valor: [ 'HOLA', 'MUZZY' ] }\n```\n\nEntonces después de tener una función fmap que devuelve el mismo tipo de objeto también podemos afirmar que un functor seguirá estas dos reglas:\n\n1. **Preserva la identidad**\n\n```javascript\n    objeto.fmap(x => x) ≍ objeto\n```\n\n2. **Es componible**\n\n```javascript\n    objeto.fmap(componer(f, g)) ≍ objeto.fmap(g).fmap(f)\n```\n\n<br>\n\nY finalmente podemos decir entonces que un objeto será un functor si cumple estas reglas:\n\n**1) Es un objeto envoltorio para contener nuestros datos**<br>\n**2) tiene una función map para iterar sobre sus propios datos**<br>\n**3) preserva la identidad**<br>\n**4) puede ser componible**<br><br>\n\n<hr>\n<div class=\"bibliography\">\nBibliografía:<br><br>\n\n- Programación funcional en JavaScript . Ed: MANNING SHELTER ISLAND. Autor: Luis Atencio.\n- [Guía mayormente adecuada para la programación funcional](https://drboolean.gitbooks.io/mostly-adequate-guide-old/content/).\nProfessor Frisby's<br>\n</div>\n",
    "path": "/es/blog/functional/functors",
    "id": "es/functional/functors"
  },
  {
    "title": "Memoizar",
    "description": "Un memoizador de funciones más avanzado",
    "pubDate": "2019-11-11",
    "tags": [
      "declarative",
      "Pure functions",
      "Inmutable",
      "currying",
      "functors"
    ],
    "categories": [
      "functional"
    ],
    "draft": false,
    "heroImage": "/blog-placeholder-9.jpg",
    "content": "\n```javascript\n// Un memoizador más funcional\n\n// Podemos potenciar nuestro módulo añadiendo funciones más adelante\nvar Memoizer = (function () {\n  // Datos privados\n  var cache = {};\n  // ¡Las funciones nombradas son increíbles!\n  function cacher(func) {\n    return function () {\n      var key = JSON.stringify(arguments);\n      if (cache[key]) {\n        return cache[key];\n      } else {\n        val = func.apply(this, arguments);\n        cache[key] = val;\n        return val;\n      }\n    };\n  }\n  // Datos públicos\n  return {\n    memo: function (func) {\n      return cacher(func);\n    },\n  };\n})();\n\nvar fib = Memoizer.memo(function (n) {\n  if (n < 2) {\n    return 1;\n  } else {\n    return fib(n - 2) + fib(n - 1);\n  }\n});\n```\n",
    "path": "/es/blog/functional/memoize",
    "id": "es/functional/memoize"
  },
  {
    "title": "monadas",
    "description": "Explorando monadas como funtores especializados para manejar datos nulos y agilizar el manejo de errores en la programación funcional",
    "pubDate": "2019-11-11",
    "tags": [
      "declarative",
      "Pure functions",
      "Inmutable",
      "currying",
      "functors"
    ],
    "categories": [
      "functional"
    ],
    "draft": true,
    "heroImage": "/blog-placeholder-8.jpg",
    "content": "\nAsí que recordemos primero qué es un functor:\n\n    1. Es un objeto envolvente para contener nuestros datos\n    2. tiene una función de mapa para iterar sobre sus propios datos\n    3. preserva la identidad\n    4. puede ser componible\n\nPero los funtores por sí mismos no son convincentes, porque no se espera que\nsepan cómo manejar casos con **datos nulos**.<br> `R.compose de Ramda`, por ejemplo,\nfallará si se le pasa una referencia a una función nula. Esto no es un defecto\nen el diseño; es intencional.\n\n- Los funtores mapean funciones de un tipo a otro.\n\n- Se puede encontrar un comportamiento más especializado en tipos de datos funcionales llamados monads.\n\n- Entre otras cosas, los monads pueden simplificar la gestión de errores en su código, permitiéndole\n  escribir composiciones de funciones fluidas.\n\n- ¿Cuál es su relación con los funtores? **Los monads son los contenedores\n  a los que los funtores \"alcanzan\".**\n",
    "path": "/es/blog/functional/monads",
    "id": "es/functional/monads"
  },
  {
    "title": "transductores",
    "description": "Explorando transductores en la programación funcional para pipelines de transformación de datos eficientes sin crear valores intermedios",
    "pubDate": "2019-01-01",
    "tags": [
      "declarative",
      "Pure functions",
      "Inmutable",
      "currying",
      "functors",
      "transducers"
    ],
    "categories": [
      "functional"
    ],
    "draft": false,
    "heroImage": "/blog-placeholder-16.jpg",
    "content": "\nEl objetivo principal de los transductores es ejecutar una canalización de transformaciones en una secuencia de entrada de valores **sin crear valores intermedios**. Las funciones que describen los cálculos están decopladas, por lo que esto hace que el diseño del programa sea más limpio y fácil de desarrollar y mantener.\n\nUn transductor es una función que acepta un transformador y devuelve un transformador y puede componerse directamente.\n\nLos transductores pueden:\n\n- Ser Componibles\n- Solo enumeran los elementos **una vez** (muy eficiente para trabajar con flujos de datos)\n- pueden usarse para evaluación perezosa o ansiosa\n- Puedes combinar un transductor para generar otro transductor (¿Reductores de alto orden?)\n\nHay dos estrategias:\n\n- **Tirar:** evaluación perezosa\n- **Empujar:** evaluación ansiosa\n\n**Tirar** espera hasta que un consumidor pida el siguiente valor (por ejemplo un Iterable)\n\n**Empujar** enumera los valores fuente y los empuja a través de los tubos lo antes posible (Array.reduce())\n\nLos transductores se componen de arriba a abajo (de izquierda a derecha)\n\n**Ejemplo:**\n\nDado un arreglo de autobots queremos:\n\n1. filtrar los valores que no contienen la letra 'r',\n2. cambiar a mayúsculas\n3. invertir cada valor\n\n**Primer enfoque sin un transductor**\n\n```javascript\nconst R = require(\"ramda\"); // Librería funcional Ramda\n\nlet autobots = [\n  \"Optimus Prime\",\n  \"Bumblebee\",\n  \"Ironhide\",\n  \"Sunstreaker\",\n  \"Ratchet\",\n];\n\n// Filtrar autobots que contienen 'r', cambiar a mayúsculas, luego invertir\nlet transform = R.compose(\n  R.filter((x) => /r/i.test(x)),\n  R.map(R.toUpper),\n  R.map(R.reverse)\n);\n\ntransform(autobots);\n// => [ 'EMIRP SUMITPO', 'EDIHNORI', 'REKAERTSNUS', 'TEHCTAR' ]\n```\n\n**Mismo enfoque con transductor**\n\n```javascript\nconst R = require(\"ramda\"); // Librería funcional Ramda\n\nlet autobots = [\n  \"Optimus Prime\",\n  \"Bumblebee\",\n  \"Ironhide\",\n  \"Sunstreaker\",\n  \"Ratchet\",\n];\n\n// Filtrar autobots que contienen 'r', cambiar a mayúsculas, luego invertir\nlet transform = R.compose(\n  R.filter((x) => /r/i.test(x)),\n  R.map(R.toUpper),\n  R.map(R.reverse)\n);\n\ntransform(autobots);\n// => [ 'EMIRP SUMITPO', 'EDIHNORI', 'REKAERTSNUS', 'TEHCTAR' ]\n```\n\nObtenemos exactamente el mismo resultado (en esta situación), pero algo muy diferente y muy poderoso ocurre por debajo. **En el primer ejemplo, se transformó toda la lista en cada paso**.<br>\nEsto significa que tuvimos que iterar sobre la lista tres veces. Sin embargo, **en el segundo ejemplo** donde usamos el transductor, **¡solo tuvimos que iterar sobre la lista una vez!**\n\n<div class=\"bibliography\">\nBibliografía:<br><br>\n\n- [effectfulJS](https://github.com/awto/effectfuljs/tree/master/packages/transducers)\n- [Entendiendo Transductores en JavaScript](https://medium.com/@roman01la/understanding-transducers-in-javascript-3500d3bd9624)\n- [MÁGICOS Y MÍSTICOS TRANSDUCTORES DE JAVASCRIPT](https://jrsinclair.com/articles/2019/magical-mystical-js-transducers/)\n- [Transductores: Canalizaciones de procesamiento de datos eficientes en JavaScript](https://medium.com/javascript-scene/transducers-efficient-data-processing-pipelines-in-javascript-7985330fe73d).\n</div>\n",
    "path": "/es/blog/functional/transducers",
    "id": "es/functional/transducers"
  },
  {
    "title": "Las variables globales son malas",
    "description": "Explorando los peligros de las variables globales en JavaScript, incluyendo la contaminación del alcance, problemas de concurrencia y mejores prácticas para la declaración de variables",
    "pubDate": "2018-06-14T00:00:00.000Z",
    "tags": [
      "javascript",
      "globals"
    ],
    "categories": [
      "javascript"
    ],
    "draft": false,
    "heroImage": "/blog-placeholder-14.jpg",
    "content": "\n## Extraído de un Gist, una explicación muy bien hecha\n\n```javascript\n// Es importante declarar tus variables.\n\n(function () {\n  var foo = \"Hola, mundo!\";\n  print(foo); //=> Hola, mundo!\n})();\nprint(foo); // De ninguna manera José !!\n\n// Porque si no lo haces, ellas se convierten en variables globales.\n\n(function () {\n  foo = \"Hola, mundo!\";\n  print(foo); //=> Hola, mundo!\n})();\n\nprint(foo); //=> WTF, devuelve \"Hola, mundo!\"\n\n// Cuando las variables globales se infiltran en tu código pueden causar problemas.\n// Especialmente en aplicaciones con concurrencia.\n\nvar contar = function () {\n  for (i = 0; i < 10; i += 1) {\n    print(i);\n  }\n};\n\ncontar(); //=> 0 1 2 3 4 5 6 7 8 9\n\nvar contarSilenciosamente = function () {\n  for (i = 0; i < 10; i += 1) {\n    // no imprime nada;\n  }\n};\n\n// Ambos bucles incrementan i al mismo tiempo, lo que causa un comportamiento extraño.\nwindow.setTimeout(contarSilenciosamente, 10);\nwindow.setTimeout(contar, 10); //=> 2 3 7 8 9\n\n// Puedes usar 'this' en las definiciones de métodos para referirte a los atributos de\n// el objeto del método.\n\nvar obj = {\n  nombre: \"foo\",\n  presentarse: function () {\n    print(this.nombre);\n  },\n};\n\nobj.presentarse(); //=> foo\n\n// Pero 'this' no sigue las reglas normales de alcance en JavaScript. Uno\n// podría esperar que 'this' esté disponible con el mismo valor a través del cierre en el\n// callback definido dentro del método aquí.\n\nvar obj = {\n  nombre: \"foo\",\n  presentarse: function () {\n    window.setTimeout(function () {\n      print(this.nombre);\n    }, 3000);\n  },\n};\n\nobj.presentarse(); //=> *pausa* undefined\n\n// De hecho, esto se ligó al objeto global en el callback. Para evitarlo,\n// asigna la referencia del objeto a una variable regular que tendrá el\n// mismo valor dentro de la definición del callback.\n\nvar obj = {\n  nombre: \"foo\",\n  presentarse: function () {\n    var eso = this;\n    window.setTimeout(function () {\n      print(eso.nombre);\n    }, 3000);\n  },\n};\n\nobj.presentarse(); //=> *pausa* foo\n\n// La palabra clave 'this' en realidad se asigna dinámicamente siempre que se\n// invoca una función. Cuando una función es invocada como un método, es decir, obj.method(), 'this'\n// se liga a 'obj'. Pero cuando una función es invocada por sí misma 'this' se liga\n// al objeto global.\n\nvar frase = \"Hola, mundo!\";\nvar imprimirFrase = function () {\n  print(this.frase);\n};\n\nimprimirFrase(); //=> Hola, mundo!\n\n// Esto es cierto incluso en funciones que fueron definidas como un método.\n\nvar obj = {\n  nombre: \"foo\",\n  presentarse: function () {\n    print(this.nombre);\n  },\n};\n\n// Cuando la función se invoca sin 'obj.' delante de ella, 'this' se convierte\n// en el espacio de nombres global.\n\nvar presentarse = obj.presentarse;\npresentarse(); //=> undefined\n\n// La invocación de método y la invocación de función son dos de los patrones de invocación\n// en JavaScript. Un tercero es la invocación de apply, que nos da control sobre qué\n// 'this' se asignará durante la ejecución de la función.\n\npresentarse.apply(obj, null); //=> foo\n\n// 'apply' es un método en Function. El primer argumento es el valor que 'this'\n// será unido. Los argumentos sucesivos a apply se pasan como argumentos a\n// la función que se está invocando.\n\nvar hablador = function (repetirVeces) {\n  var i;\n  for (i = 0; i < repetirVeces; i += 1) {\n    print(this.nombre + \" \");\n  }\n};\nhablador.apply(obj, 3); //=> foo foo foo\n\n// El cuarto y último patrón de invocación en JavaScript es la invocación de constructor\n// Este patrón fue diseñado para proporcionar una forma de crear nuevos objetos\n// que parecerían familiares a los programadores que están acostumbrados a programar con\n// clases.\n\nvar Gato = function (nombre) {\n  this.nombre = nombre;\n};\nGato.prototype = {\n  pregunta: function () {\n    print(this.nombre + ' dice, \"miau\"');\n  },\n};\n\n// Cuando una función es llamada con la palabra clave 'new' delante de ella, un nuevo\n// objeto es creado y se une a 'this' cuando la función se ejecuta. Las funciones de constructor especiales usan esta característica para personalizar nuevos objetos a medida que son\n// creados.\n\nvar bigotes = new Gato(\"bigotes\");\nbigotes.pregunta(); //=> bigotes dice \"miau\"\n\n// Cuando un nuevo objeto es creado con 'new', el prototipo del nuevo objeto es\n// establecido al prototipo de la función constructora. Así que el nuevo objeto hereda\n// todos los atributos del valor del prototipo del constructor. En este caso,\n// los nuevos objetos gato heredan el método 'pregunta' de Gato.prototype.\n\nvar masticador = new Gato(\"masticador\");\nmasticador.pregunta(); //=> masticador dice \"miau\"\n\n// Si una función constructora es llamada sin la palabra clave 'new', se invoca\n// con el patrón ordinario de invocación de funciones.\n\nvar atrapado = Gato(\"atrapado!\");\natrapado.pregunta(); //=> typein:165: TypeError: atrapado no tiene propiedades\n\n// Así que 'this' se asigna al objeto global en lugar de a un objeto recién creado. Eso significa que cualquier atributo asignado al nuevo objeto por la función constructora se convierte en variables globales!\n\nprint(nombre); //=> atrapado!\n\n// La invocación del constructor es bastante complicada y propensa a la creación de variables globales desastrosas. Aquí hay una forma más limpia de crear nuevos objetos que hereden\n// de otros objetos.\n\n// Esto define Object.create, un método que simplifica el comportamiento de la\n// palabra clave 'new'. Este método fue inventado por Douglas Crockford.\n// http://javascript.crockford.com/prototypal.html\nif (typeof Object.create !== \"function\") {\n  Object.create = function (o) {\n    var F = function () {};\n    F.prototype = o;\n    return new F();\n  };\n}\n\n// Object.create(obj) devuelve un nuevo objeto que hereda todos los atributos\n// de obj. El objeto prototipo 'gato' aquí define un método 'clonar' que envuelve\n// Object.create para personalizar nuevos objetos 'gato' a medida que se crean.\n\nvar gato = {\n  pregunta: function () {\n    print(this.nombre + ' dice \"miau\"');\n  },\n  clonar: function (nombre) {\n    var nuevoGato = Object.create(this);\n    nuevoGato.nombre = nombre;\n    return nuevoGato;\n  },\n};\n\nvar peludo = gato.clonar(\"peludo\");\npeludo.pregunta(); //=> peludo dice \"miau\"\n\n// Además de heredar 'pregunta', los nuevos gatos también heredan 'clonar'.\n\nvar peludo2 = peludo.clonar(\"peludo2\");\npeludo2.pregunta(); //=> peludo2 dice \"miau\"\n\n// Los métodos y atributos se heredan, no se copian. Si cambias la\n// definición de 'clonar' en 'gato' en este punto, el cambio se reflejará\n// en objetos gato que ya han sido creados.\n\npeludo2.hasOwnProperty(\"clonar\"); //=> false\npeludo.hasOwnProperty(\"clonar\"); //=> false\ngato.hasOwnProperty(\"clonar\"); //=> true\n```\n\n<br>\n<div class=\"bibliography\">\nBibliografía:<br>\nhttps://gist.github.com/hallettj/64478\n</div>\n",
    "path": "/es/blog/global-variables-are-bad",
    "id": "es/global-variables-are-bad"
  },
  {
    "title": "Ámbito léxico y dinámico",
    "description": "Entendiendo el ámbito léxico y dinámico en JavaScript, incluyendo la palabra clave eval y sus implicaciones en el rendimiento",
    "pubDate": "2018-01-14T00:00:00.000Z",
    "tags": [
      "scope",
      "eval",
      "javascript",
      "declarative"
    ],
    "categories": [
      "javascript"
    ],
    "draft": false,
    "heroImage": "/blog-placeholder-18.jpg",
    "content": "\n# Alcance léxico\n\n## Eval malvado\n\nPodemos hacer trampa con el alcance léxico usando la palabra clave eval. <br>\nLa palabra clave eval, toma cualquier cadena dada y la trata como si fuera un código\n\n```javascript\nvar bar = \"foo\";\nfunction foo(str) {\n  eval(str);\n  console.log(\"bar\"); // 42 !!!!\n}\n\nfoo(\"var bar = 42\");\n```\n\nEl problema de hacer esto es que el rendimiento se verá afectado porque, como sabemos, JS primero asigna el LHS (lado izquierdo), lo cual significa que leerá todas las asignaciones en el lado izquierdo y luego hará el lado derecho del código. En el caso de la función eval estamos utilizando un RHS que contiene una declaración LHS y RHS y eso significa que el compilador de JS no podrá hacer una optimización de código porque el motor no puede asumir que el alcance léxico será inalterable. Entonces, incluso si declaramos un eval y no lo usamos para hacer una declaración, tendrá un efecto secundario en el rendimiento de nuestro código. <br>\nAsí que para resumir en general no deberíamos usar la clave eval\n\n## with with\n\nTambién podemos saltarnos el alcance léxico haciendo algo aún peor, y eso es usar la declaración with\n\n## Nota sobre LHS y RHS\n\nLa búsqueda de LHS se realiza cuando una variable aparece en el lado izquierdo de una operación de asignación, y una búsqueda de RHS se realiza cuando una variable aparece en el lado derecho de una operación de asignación.\n\nLo pienso de la siguiente manera: <br>\nla búsqueda de lhs es una búsqueda de contenedor <br>\nla búsqueda de rhs es una búsqueda de valor <br>\n\n## Alcance dinámico\n\nEl alcance dinámico se refiere a un mecanismo de alcance donde las variables se resuelven buscando en la pila de llamadas, en lugar de por la estructura del código (como ocurre con el alcance léxico). En el alcance dinámico, el contexto en el que se llama a una función determina las vinculaciones de las variables, no el lugar donde la función fue definida.\n\nJavaScript utiliza alcance léxico (estático), pero algunos comportamientos—como el valor de `this`—pueden parecerse al alcance dinámico porque `this` se determina por cómo se invoca una función, no por dónde está escrita.\n\n### Ejemplo: Simulando alcance dinámico con `this`\n\n```javascript\nvar name = \"global\";\n\nfunction printName() {\n  console.log(this.name);\n}\n\nvar obj = {\n  name: \"object\",\n  printName: printName,\n};\n\nprintName(); // \"global\" (this se refiere al objeto global)\nobj.printName(); // \"object\" (this se refiere a obj)\n```\n\nEn el ejemplo anterior, el valor de `this` dentro de `printName` depende de cómo se llama a la función, no de dónde fue definida. Esto es similar al alcance dinámico.\n\n### Diferencias clave\n\n- **Alcance léxico**: La resolución de variables se basa en dónde se escriben las funciones y los bloques en el código.\n- **Alcance dinámico**: La resolución de variables se basa en la pila de llamadas en tiempo de ejecución.\n\nJavaScript no tiene un alcance dinámico real para las variables, pero entender cómo funcionan `this` y ciertos constructos puede ayudar a evitar confusiones.\n\n<div class=\"bibliography\">\n\n## Bibliografía:\n\nhttps://stackoverflow.com/questions/36383795/javascript-lhs-and-rhs-lookup\nCurso de Plural sight: Javascript avanzado, por Kyle Simpson\n\n</div>\n",
    "path": "/es/blog/lexical-and-dynamic-scope",
    "id": "es/lexical-and-dynamic-scope"
  },
  {
    "title": "Encadenamiento de métodos en javascript",
    "description": "Comprendiendo el encadenamiento de métodos en JavaScript para crear interfaces fluidas y mejorar la legibilidad del código a través de llamadas a métodos secuenciales",
    "pubDate": "2018-01-08T00:00:00.000Z",
    "tags": [
      "javascript",
      "method chaining"
    ],
    "categories": [
      "javascript"
    ],
    "draft": false,
    "heroImage": "/blog-placeholder-20.jpg",
    "content": "\n# Encadenamiento de métodos en Javascript\n\nde [wikipedia](https://en.wikipedia.org/wiki/Method_chaining) <br>\nEl encadenamiento de métodos, también conocido como idiom de parámetro nombrado, es una sintaxis común para invocar múltiples llamadas a métodos en lenguajes de programación orientados a objetos.\n\nLa clave para lograr esto es que cada método devuelve un objeto, permitiendo que las llamadas se encadenen en una sola declaración sin requerir variables para almacenar los resultados intermedios.\n\nUna sintaxis similar es el cascading de métodos, donde después de la llamada al método, la expresión se evalúa al objeto actual, no al valor de retorno del método. El cascading puede implementarse usando el encadenamiento de métodos al hacer que el método devuelva el propio objeto actual. El cascading es una técnica clave en las interfaces fluidas, y dado que el encadenamiento está ampliamente implementado en lenguajes orientados a objetos mientras que el cascading no, esta forma de \"cascading mediante encadenamiento al devolver this\" a menudo se denomina simplemente como \"encadenamiento\". Ambos, el encadenamiento y el cascading provienen del lenguaje Smalltalk.\n\nMientras que el encadenamiento es sintaxis, tiene consecuencias semánticas, a saber, que requiere que los métodos devuelvan un objeto, y si se implementa el cascading mediante encadenamiento, este debe ser el objeto actual. Esto evita que el valor de retorno se utilice para algún otro propósito, como devolver un valor de error.\n\nPara ver un ejemplo primero definamos nuestro caso de uso:\n\nImagina que tenemos una clase persona que tiene algunos métodos (o funciones), estos son:\n\n```javascript\nsetName();\nsetEyeColor();\nsetHairColor();\nsetHeight();\n```\n\nY esta es la definición de nuestra clase\n\n```javascript\n// Definición de la clase\n// ------------------------\nclass Person {\n  constructor() {\n    console.log(\"persona creada\");\n  }\n\n  setName(name) {\n    this.name = name;\n    return this;\n  }\n\n  setEyeColor(eyeColor) {\n    this.eyeColor = eyeColor;\n    return this;\n  }\n\n  setHairColor(hairColor) {\n    this.HairColor = hairColor;\n    return this;\n  }\n\n  setHeight(height) {\n    this.height = height;\n    return this;\n  }\n}\n```\n\nY ahora podemos hacer encadenamiento de métodos.\n\n```javascript\nconsole.log(\n  new Person()\n    .setName(\"Dina\")\n    .setEyeColor(\"black\")\n    .setHairColor(\"brown\")\n    .setHeight(\"1.85\")\n);\n\n// Person {HairColor:\"brown\", eyeColor:\"black\", height:\"1.85\", name:\"Dina\"}\n```\n",
    "path": "/es/blog/method-chaining-in-javascript",
    "id": "es/method-chaining-in-javascript"
  },
  {
    "title": "Propiedades de atributos de objetos",
    "description": "Explorando los atributos de las propiedades de los objetos JavaScript; value, configurable, enumerable y writable",
    "pubDate": "2018-01-12T00:00:00.000Z",
    "tags": [
      "javascript",
      "object properties"
    ],
    "categories": [
      "javascript"
    ],
    "draft": false,
    "heroImage": "/blog-placeholder-19.jpg",
    "content": "\n# Entendiendo los atributos de las propiedades de objetos en JavaScript\n\nLos objetos en JavaScript son fundamentales en el lenguaje, y comprender los atributos de sus propiedades es esencial para escribir código robusto y mantenible. En este artículo exploramos los cuatro atributos clave de las propiedades en JavaScript: **value**, **configurable**, **enumerable** y **writable**. Dominar estos atributos te permite controlar el comportamiento de las propiedades de los objetos, algo crucial para el desarrollo avanzado en JavaScript y la programación orientada a objetos.\n\n## ¿Qué son los atributos de las propiedades de un objeto en JavaScript?\n\nCada propiedad de un objeto en JavaScript posee un conjunto de atributos internos que definen su comportamiento. Estos atributos determinan cómo se puede acceder, modificar o enumerar la propiedad. Los cuatro atributos principales son:\n\n### 1. value\n\nEl atributo **value** almacena el dato real de la propiedad. Puede ser cualquier valor válido de JavaScript, como una cadena, número, objeto o función.\n\n### 2. configurable\n\nEl atributo **configurable** especifica si la propiedad puede ser eliminada del objeto o si sus atributos (excepto value y writable) pueden ser modificados. Si se establece en `false`, no podrás eliminar la propiedad ni cambiar sus otros atributos.\n\n### 3. enumerable\n\nEl atributo **enumerable** determina si la propiedad aparecerá durante la enumeración de propiedades, como en un bucle `for...in` o al usar `Object.keys()`.\n\n### 4. writable\n\nEl atributo **writable** controla si el valor de la propiedad puede ser modificado mediante asignación. Si `writable` es `false`, los intentos de modificar la propiedad fallarán silenciosamente (en modo no estricto) o lanzarán un error (en modo estricto).\n\n## ¿Por qué son importantes los atributos de las propiedades?\n\nComprender y utilizar los atributos de las propiedades en JavaScript te permite:\n\n- Crear propiedades inmutables o de solo lectura\n- Ocultar detalles internos de implementación\n- Prevenir la eliminación o modificación accidental de propiedades críticas\n- Ajustar el comportamiento de los objetos para mayor seguridad y mantenibilidad\n\nPuedes definir o modificar estos atributos usando `Object.defineProperty()` o `Object.defineProperties()`.\n\n## Ejemplo: Definiendo atributos de propiedades\n\n```js\nconst usuario = {};\nObject.defineProperty(usuario, \"id\", {\n  value: 123,\n  writable: false,\n  enumerable: true,\n  configurable: false,\n});\n```\n\nEn este ejemplo, la propiedad `id` es de solo lectura y no puede ser eliminada ni reconfigurada, pero sí aparecerá en las enumeraciones.\n\n## Conclusión\n\nLos atributos de las propiedades de los objetos en JavaScript—**value**, **configurable**, **enumerable** y **writable**—te otorgan un control detallado sobre tus objetos. Aprovechar estos atributos es una buena práctica para construir aplicaciones JavaScript seguras, predecibles y fáciles de mantener.\n\n---\n\n### Referencias\n\n[Yeison Daza – Entendiendo los objetos en JavaScript](https://medium.com/entendiendo-javascript/entendiendo-los-objetos-en-javascript-3a6d3a0695e5)\n",
    "path": "/es/blog/object-atribute-properties",
    "id": "es/object-atribute-properties"
  },
  {
    "title": "Renderizado condicional explícito",
    "description": "Un patrón funcional y mantenible para condicionar fragmentos de UI sin abusar de operadores lógicos ni ternarios.",
    "pubDate": "2025-07-28T00:00:00.000Z",
    "categories": [
      "design patterns"
    ],
    "tags": [
      "Astro",
      "Functional UI",
      "JSX",
      "Components",
      "patterns"
    ],
    "draft": false,
    "heroImage": "/blog-placeholder-23.jpg",
    "content": "\nEn entornos JSX como Astro, condicionar bloques de contenido es algo habitual. Pero si abusas de ternarios o `&&`, el código acaba pareciendo un acertijo.\n\nEste patrón propone encapsular la lógica de visibilidad en un componente semántico y reutilizable: `ShowWhen.astro`.\n\n## El problema\n\n```astro\n<section>\n  {\n    currentPage === 1 && (\n      <div>\n        <h2>{t(lang, \"blogList.title\")}</h2>\n        <p>{t(lang, \"blogList.description\")}</p>\n      </div>\n    )\n  }\n</section>\n```\n\nEste patrón es **funcional, pero opaco.** El `&&` exige conocer precedencia y estructura. Escribir lógica más compleja o anidarla lo rompe.\n\n## La solución:\n\nCreamos un componente dedicado a representar el _intento semántico_: mostrar contenido si se cumple una condición.\n\n### `components/ShowWhen.astro`\n\n```astro\n---\nconst { when, children } = Astro.props;\n---\n\n{when && children}\n```\n\n**Así de simple.** Cualquier bloque de JSX puede ahora ser mostrado o no de forma explícita.\n\n## Ejemplo de uso\n\n```astro\n---\nimport ShowWhen from \"~/components/ShowWhen.astro\";\n---\n\n<section>\n<ShowWhen when={currentPage === 1}>\n    <div>\n        <h2>{t(lang, \"blogList.title\")}</h2>\n        <p>{t(lang, \"blogList.description\")}</p>\n      </div>\n</ShowWhen>\n</section>\n```\n\n## Ventajas\n\n- ✅ **Legibilidad**: El `when` expresa el propósito. No necesitas descifrar expresiones.\n- ✅ **Reutilización**: Se puede extender con logging, trazas de debug o animaciones de entrada/salida.\n- ✅ **Separación de concerns**: La lógica de visibilidad se abstrae fuera del markup principal.\n- ✅ **Funciona en server components y layouts**: sin efectos colaterales.\n\n## Variantes\n\nPodemos combinar este patrón con versiones más estructuradas:\n\n```astro\n<If condition={isLoading}>\n  <Then>\n    <Spinner />\n  </Then>\n  <Else>\n    <Content />\n  </Else>\n</If>\n```\n\nAunque esto añade más complejidad, puede ser útil en flujos ramificados o cuando queremos reutilizar lógica declarativa en múltiples puntos.\n\n## Conclusión\n\nNo se trata solo de hacer que funcione. Se trata de hacer que el código comunique _qué intenta hacer_.\n\nEl componente encapsula una intención común de la UI: **mostrar algo si se cumple una condición**.\n",
    "path": "/es/blog/patterns/conditional-rendering-with-show.astro",
    "id": "es/patterns/conditional-rendering-with-show.astro"
  },
  {
    "title": "IIFE",
    "description": "Comprendiendo las Expresiones de Función Inmediatamente Invocadas (IIFE) en JavaScript y su uso en la prevención de la contaminación del ámbito global",
    "pubDate": "2018-01-14T00:00:00.000Z",
    "tags": [
      "design patterns",
      "IIFE"
    ],
    "categories": [
      "design patterns"
    ],
    "draft": false,
    "heroImage": "/blog-placeholder-6.jpg",
    "content": "\n# IIFE - Expresión de función invocada inmediatamente\n\n```javascript\nvar foo = \"foo1\";\n\n(function () {\n  var foo = \"foo2\";\n  console.log(foo); // foo2\n})();\n\nconsole.log(foo); // foo1\n\n// también podemos escribir la declaración anterior así:\n(function () {\n  // código\n})();\n```\n\nUsamos IIFE para no contaminar el alcance global.\n\n<div class=\"bibliography\">\nBibliografía: <br/><br/>\n\n- Ben Alman: [Expresión de función invocada inmediatamente (IIFE)](http://benalman.com/news/2010/11/immediately-invoked-function-expression/)\n\n</div>\n",
    "path": "/es/blog/patterns/iife",
    "id": "es/patterns/iife"
  },
  {
    "title": "Mixins",
    "description": "Entendiendo los mixins en JavaScript como una solución para la multi-herencia, incluyendo los patrones de delegación, concatenación y herencia funcional",
    "pubDate": "2018-11-18T00:00:00.000Z",
    "tags": [
      "design patterns",
      "mixins",
      "functional mixins",
      "inherence"
    ],
    "categories": [
      "design patterns"
    ],
    "draft": false,
    "heroImage": "/blog-placeholder-7.jpg",
    "content": "\nEn JavaScript solo podemos heredar de un único objeto. Solo puede haber un **[[Prototype]]** para\nun objeto.\nY una clase puede extender solamente una otra clase.\n\n**Para resolver el uso de la múltiple herencia usamos mixins**.\n\nEn lenguajes de programación orientada a objetos, un Mixin es una clase que contiene métodos para uso de\notras clases sin necesidad de ser la clase padre de esas otras clases.\n\nUn mixin también puede ser visto como una **interfaz con métodos implementados**.\nEste patrón es un ejemplo de la aplicación del [**principio de inversión de dependencia**](https://en.wikipedia.org/wiki/Dependency_inversion_principle).\n\n## Heredando \"métodos\"\n\nJavaScript no tiene métodos en la forma en que los lenguajes basados en clases los definen.\n**En JavaScript, cualquier función puede ser agregada a un objeto en la forma de una propiedad**.\nUna función heredada actúa igual que cualquier otra propiedad, incluyendo la sombra de propiedad\n\nExisten más de un tipo de herencia prototípica:\n\n- **Delegación** (es decir, la cadena de prototipo).\n- **Concatenativa** (es decir, mixins, `Object.assign()`).\n- **Funcional** (No confundir con programación funcional. Una función utilizada para crear un\n  cierre para el estado privado/encapsulación).\n\nCada tipo de herencia prototípica tiene su propio conjunto de casos de uso, pero todos ellos son igualmente\nútiles en su capacidad para habilitar la composición, que crea relaciones **tiene-un** o **usa-un** o **puede-hacer**\nen lugar de la relación es-un creada con la herencia de clase.\n\n## Delegación\n\nPodemos trabajar con delegación usando apply, bind o call para heredar de otro objeto. Veamos\nun ejemplo: <br>\n\n```javascript\nfunction Producto(nombre, precio) {\n  this.nombre = nombre;\n  this.precio = precio;\n}\n\nfunction Comida(nombre, precio) {\n  Producto.call(this, nombre, precio);\n  this.categoria = \"comida\";\n}\n\nfunction Juguete(nombre, precio) {\n  Producto.call(this, nombre, precio);\n  this.categoria = \"juguete\";\n}\n\nvar queso = new Comida(\"feta\", 5);\nvar diversion = new Juguete(\"robot\", 40);\n```\n\n<a href=\"../testing-protoype-inheritance/\" target=\"_self\">Este es otro ejemplo \"complicado\"\n</a>\n\n## Concatenativa\n\n**Usando Object.assign() como mixin**\n\n```javascript\n// mixin\nlet decirHolaMixin = {\n  decirHola() {\n    alert(`Hola ${this.nombre}`);\n  },\n  decirAdios() {\n    alert(`Adiós ${this.nombre}`);\n  },\n};\n\n// uso:\nconst Usuario = function (nombre) {\n  this.nombre = nombre;\n};\n\n// copiamos los métodos\nObject.assign(Usuario.prototype, decirHolaMixin);\n// ahora Usuario puede decir hola\nnew Usuario(\"Chico\").decirHola(); // ¡Hola Chico!\n```\n\n**o si estuvieras utilizando clases podrías hacer algo como esto:**\n\n```javascript\nclass Usuario extends Persona {\n  // ...\n}\n\nObject.assign(Usuario.prototype, decirHolaMixin);\n```\n\n### Mixins Funcionales\n\nSi las funciones definidas por los mixins están pensadas solamente para el uso de otros objetos,\n¿por qué molestarse en crear mixins como objetos regulares en absoluto? Dicho de otra manera, un **mixin debería ser un\nproceso no un objeto**.\n\nLa conclusión lógica es hacer nuestros mixins en funciones en las que los objetos consumidores se inyecten\na sí mismos por delegación, eliminando así al intermediario (la función extend) por completo.\n\n```javascript\nvar comoCírculo = function () {\n  this.area = function () {\n    return Math.PI * this.radio * this.radio;\n  };\n  this.crecer = function () {\n    this.radio++;\n  };\n  this.encoger = function () {\n    this.radio--;\n  };\n  return this;\n};\n\nvar Círculo = function (radio) {\n  this.radio = radio;\n};\n\ncomoCírculo.call(Círculo.prototype);\n\nvar circulo1 = new Círculo(5);\ncirculo1.area(); //78.54\n```\n\n**Mixins como verbos en lugar de sustantivos**\n\n### Añadir opciones\n\nEsta estrategia funcional también permite que los comportamientos prestados sean parametrizados mediante\nun argumento de opciones.\n\n```javascript\nvar comoÓvalo = function ({ crecerPor, encogerPor }) {\n  this.area = function () {\n    /* ... */\n  };\n  this.ratio = function () {\n    /* ...*/\n  };\n  this.crecer = function () {\n    this.radioCorto += crecerPor / this.ratio();\n    this.radioLargo += crecerPor;\n  };\n  // ...\n  return this;\n};\n\nvar BotónÓvalo = function (/*...*/) {\n  //...\n};\n// ...\ncomoÓvalo.call(BotónÓvalo.prototype, { crecerPor: 2, encogerPor: 2 });\n```\n\n**Lectura adicional [Traits](https://github.com/traitsjs/traits.js)**\n\n<div class=\"bibliography\">\n\n## Bibliografía:\n\n[Angus Croll](https://javascriptweblog.wordpress.com/2011/05/31/a-fresh-look-at-javascript-mixins/?blogsub=confirming%23subscribe-blog]) <br/>\n[javascript.info](https://javascript.info/mixins)<br/>\n[Wikipedia](https://es.wikipedia.org/wiki/Mixin)<br/>\n[Eric Elliott](https://medium.com/javascript-scene/10-interview-questions-every-javascript-developer-should-know-6fa6bdf5ad95)<br/>\n[developer.mozilla](https://developer.mozilla.org/es/docs/Web/JavaScript/Herencia_y_la_cadena_de_protipos)<br/>\n\n</div>\n",
    "path": "/es/blog/patterns/mixins",
    "id": "es/patterns/mixins"
  },
  {
    "title": "probando la herencia del prototipo",
    "description": "Explorando la herencia de prototipos en JavaScript utilizando el método call para heredar propiedades y métodos entre objetos y funciones",
    "pubDate": "2018-11-21T00:00:00.000Z",
    "tags": [
      "design patterns",
      "prototype",
      "inheritance"
    ],
    "categories": [
      "design patterns"
    ],
    "draft": false,
    "heroImage": "/blog-placeholder-17.jpg",
    "content": "\nhttps://stackoverflow.com/questions/53406070/using-call-to-inherit-objects-from-a-function\n\n```js\n// probando Call para heredar objetos / funciones\n// -------------------------------------------\n\n// declaramos nuestra primera función\nconst funcA = function (nombre) {\n  this.nombre = nombre;\n  this.getNombre = function () {\n    return \"Mi nombre es \" + this.nombre;\n  };\n  return this;\n};\n// Creamos un objeto a partir de esa función\nconst objA = new funcA(\"Rodrigo\");\n\n// declarar segunda función\nconst funcB = function (apellido) {\n  this.apellido = apellido;\n  this.getApellido = function () {\n    return \"Mi apellido es \" + this.apellido;\n  };\n  return this;\n};\n\n// Crea un objeto a partir de funcB y ObjectA\nconst objC = funcB.call(objA, \"Erades\");\n// Obtenemos un objecto\nconsole.log(\"TIPO DE: \", typeof objC);\nconsole.log(\"crudo:\", objC);\nconsole.log(\"método A: \", objC.getNombre());\nconsole.log(\"prop A: \", objC.nombre);\nconsole.log(\"método B: \", objC.getApellido());\nconsole.log(\"prop B: \", objC.apellido);\nconsole.log(\"------------\");\n\n// si no queremos crear un objeto a partir de una función y un objeto,\n// podríamos heredar dos funciones también, pero el resultado realmente me sorprende\nconst funcC = funcB.call(funcA, \"Alonso\");\n// ¡¡¡¡¡Obtenemos una función!!!!!\nconsole.log(\"TIPO DE: \", typeof funcC);\nconsole.log(\"crudo:\", funcC);\n// Para obtener resultados necesitamos hacer esto:\nconsole.log(\"método ==>: \", funcC(\"Rui\"));\nconsole.log(\"método A: \", funcC(\"Rui\").getNombre());\nconsole.log(\"prop A: \", funcC(\"Maria\").nombre);\nconsole.log(\"método B: \", funcC.getApellido());\nconsole.log(\"prop B: \", funcC.apellido);\nconsole.log(\"------------\");\n```\n",
    "path": "/es/blog/patterns/testing-protoype-inheritance",
    "id": "es/patterns/testing-protoype-inheritance"
  },
  {
    "title": "declaración de ramificación Vs micro-ramificación",
    "description": "Comparando la bifurcación de declaraciones tradicionales con técnicas de micro-bifurcación en JavaScript para un código más mantenible y funcional",
    "pubDate": "2018-06-06T00:00:00.000Z",
    "tags": [
      "statement branching",
      "micro-branching strategies"
    ],
    "categories": [
      "javascript",
      "functional"
    ],
    "draft": false,
    "heroImage": "/blog-placeholder-25.png",
    "content": "\n## ramificación de sentencias\n\nCualquier estructura que altera la secuencia de ejecución dentro del ámbito global o funcional. <br>\nEsto incluye:<br>\n\n```\nif\nelse\nswitch\nfor\nwhile\n```\n\nLas sentencias están diseñadas para ejecutarse de forma no lineal. Además del evidente efecto de hinchazón, la ramificación de sentencias tiende a volverse poco intuitiva a medida que avanza.\n\n## micro-ramificación\n\nLógica condicional contenida dentro de una sentencia que no afecta a la secuencia de ejecución de la sentencia.<br>\nLos siguientes operadores facilitan la micro-ramificación: <br>\n\n```\nternary (<cond> ? a : b)\n&&\n||\n```\n\nLa lógica fluye secuencialmente de arriba a abajo e incluso de izquierda a derecha. No hay bifurcaciones en el camino. Solo hay una sentencia de retorno y está al final, donde esperamos que esté. Lo mejor de todo es que es corto. Nada se desperdicia. De hecho, es lo suficientemente conciso como para ser apenas procedimental en absoluto.\n\nLas alternativas a la ramificación de sentencias se dividen en dos amplias categorías: **micro-ramificación** y **sin ramificación en absoluto**\n\n## Estrategias de micro-ramificación\n\n### Guardias (&&) y valores predeterminados (||)\n\n```javascript\n//invocar callback si hay uno\ncallback && callback();\n//retrasar por argumento o 20\ndelayBy(delay || 20);\n//eliminar el nodo de su padre\nnode && node.parent && node.parent.removeChild(node);\n//registrar una prueba en la consola si tenemos una\nwindow.console && console.log(\"test\");\n```\n\n<br>\n\n<blockquote> Algunas cosas tienen un lugar natural. Los pájaros en el cielo, los peces en el mar y una declaración de retorno al final de una función.</blockquote>\n\n<br>\n\n<div class=\"bibliography\">\nBibliografía:<br>\nhttps://javascriptweblog.wordpress.com/2010/07/26/no-more-ifs-alternatives-to-statement-branching-in-javascript/\n</div>\n",
    "path": "/es/blog/statement-branching-vs-micro-branching",
    "id": "es/statement-branching-vs-micro-branching"
  },
  {
    "title": "WPO: Web Performance Optimization",
    "description": "Expolorando la mejora de la optimización web con AI con los core web vitals",
    "pubDate": "2025-08-26T00:00:00.000Z",
    "tags": [
      "javascript",
      "wpo",
      "google-core-web-vitals"
    ],
    "categories": [
      "javascript",
      "best-practices",
      "core-web-vitals",
      "wpo"
    ],
    "draft": true,
    "heroImage": "/blog-placeholder-14.jpg",
    "content": "\n## Exploración inicial\n\nDespués de crear esta web app [erades.com](https://erades.com) , me voy a centrar el los core web vitals de google.\n\nPara esta tare me voy a centrar en lighthouse.\n\nLos primeros resultados son estos:\n\n### 2025-08-12\n\n#### Desktop\n\n- [Home](../../../../assets/lighthouse/2025-08-12-HOME.html)\n- [Post](../../../../assets/lighthouse/2025-08-12-POST.html)\n- [Search](../../../../assets/lighthouse/2025-08-12-SEARCH.html)\n- [Tags](../../../../assets/lighthouse/2025-08-12-TAGS.html)\n- [Blog](../../../../assets/lighthouse/2025-08-12-BLOG.html)\n\n#### mobile\n\n- [Home](../../../../assets/lighthouse/2025-08-12-HOME-mobile.html)\n- [Post](../../../../assets/lighthouse/2025-08-12-POST-mobile.html)\n- [Search](../../../../assets/lighthouse/2025-08-12-SEARCH-mobile.html)\n- [Tags](../../../../assets/lighthouse/2025-08-12-TAGS-mobile.html)\n- [Blog](../../../../assets/lighthouse/2025-08-12-BLOG-mobile.html)\n\n## Primeros pensamientos\n\nLos datos arrojan buenos resultados en parte se debe al stack tecnológico utilizado (Server side rendering y static site generation) y el meta-framework seleccionado Astro.\n\nPero para conseguir unos datos aceptables el desarrollador tiene que ser experto y haber peleado mucho en batallas de front para entender las mejores prácticas.\n\nAun así siempre se escapan cosas y se debería de tener una forma de controlar los core web vitals desde el principio para poder ir mejorando los números.\n\nPor otro lado para conseguir esto habría que incluir estas comprobaciones de forma programática.\n\nHoy en día los test unitarios y los e2e o funcionales forman parte ya del ADN de los desarrolladores, sin embargo veo que los test automáticos de regresión visual y los test de performance no acaban de calar en los desarrolladores , en parte creo que es por el aumento del tiempo al para ejecutar las pipelines.\n\nSin embargo considero que de los test automáticos de regresión visual son esenciales, de hecho si tuviera que elegir entre test unitarios o de componentes y test de regresión visual optaría por los de regresión.\n\nEn el caso de los test para WPO los desarrolladores creo que no se dan cuenta el valor que suponen estos test para negocio y piensan más en el trabajo que les supone realizar esos test que en el beneficio\n\n## Planteamiento del trabajo\n\n- Para poder sacar estadísticas de forma programática voy a buscar la forma de implementar lighthouse o herramientas parecidas\n\n### Plan de ataque (síntesis)\n\n1. Métricas de laboratorio automatizadas (synthetic): Lighthouse CI en local y en CI, con presupuestos de rendimiento y aserciones que rompen el build cuando te pasas. Reportes HTML/JSON almacenados como artefactos y/o en un servidor LHCI. ￼ ￼\n2. Métricas de campo (RUM): web-vitals en producción para LCP/INP/CLS reales, enviados a tu backend/GA4. Esto te evita optimizar a ciegas. ￼ ￼\n3. Benchmarks públicos: PSI/CrUX en CI para ver cómo te mide Google (Lighthouse + datos reales agregados). ￼ ￼\n4. Opcional power-up: sitespeed.io para rastrear múltiples URLs, grabar vídeos/filmstrips y presupuestos más finos; sube resultados a S3/GCS. ￼\n\n### Lighthouse\n\nInstalado lighthouse\n\nAlternativa rápida ejecutar:\n\n```bash\nnpx unlighthouse --site https://erades.com\n```\n\nEsto te da las métricas de todo el site.\n",
    "path": "/es/blog/wpo/wpo",
    "id": "es/wpo/wpo"
  }
]